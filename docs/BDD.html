<!DOCTYPE html>
<html lang="en">

<head>
  
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Devo Applications Builder BDD</title>

  <script src="https://cdn.jsdelivr.net/gh/google/code-prettify@master/loader/run_prettify.js"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  <script src="./build/entry.js"></script>
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->
  <link href="https://fonts.googleapis.com/css?family=Roboto:100,400,700|Inconsolata,700" rel="stylesheet">
  <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.6.3/css/all.css" integrity="sha384-UHRtZLI+pbxtHCWp1t77Bi1L4ZtiqrqD80Kn4Z8NTSRyMA2Fd33n5dQ8lWUE00s/" crossorigin="anonymous">
  <link type="text/css" rel="stylesheet" href="https://jmblog.github.io/color-themes-for-google-code-prettify/themes/tomorrow-night.min.css">
  <link type="text/css" rel="stylesheet" href="styles/app.min.css">
  <link type="text/css" rel="stylesheet" href="styles/iframe.css">
  <link type="text/css" rel="stylesheet" href="">
  <script async defer src="https://buttons.github.io/buttons.js"></script>

  
</head>



<body class="layout small-header">
    <div id="stickyNavbarOverlay"></div>
    

<div class="top-nav">
    <div class="inner">
        <a id="hamburger" role="button" class="navbar-burger" aria-label="menu" aria-expanded="false">
            <span aria-hidden="true"></span>
            <span aria-hidden="true"></span>
            <span aria-hidden="true"></span>
        </a>
        <div class="logo">
            
             
                <a href="index.html">
                    <h1 class="navbar-item">Devo Applications Builder</h1>
                </a>
            
        </div>
        <div class="menu">
            
            <div class="navigation">
                <a
                    href="index.html"
                    class="link"
                >
                    API Documentation
                </a>
                
                <div class="dropdown is-hoverable is-right">
                    <a class="dropdown-trigger link">
                        Tutorials
                        <i class="fas fa-chevron-down fa-xs"></i>
                    </a>
                    <div class="dropdown-menu">
                        <div class="dropdown-content">
                        
                            <a class="dropdown-item" href="tutorial-basics.html">
                                Getting started
                            </a>
                        
                            <a class="dropdown-item" href="tutorial-configurations.html">
                                Advanced
                            </a>
                        
                            <a class="dropdown-item" href="tutorial-widgets.html">
                                Widgets
                            </a>
                        
                        </div>
                    </div>
                </div>
                
                 
                    
                        <a
                            class="link user-link "
                            href="https://github.com/SoftwareBrothers/admin-bro"
                        >
                            Github
                        </a>
                    
                        <a
                            class="link user-link "
                            href="https://admin-bro-example-app.herokuapp.com/admin"
                        >
                            Example Application
                        </a>
                    
                
                
            </div>
        </div>
    </div>
</div>
    <div id="main">
        <div
            class="sidebar "
            id="sidebarNav"
        >
            
                <div class="search-wrapper">
                    <input id="search" type="text" placeholder="Search docs..." class="input">
                </div>
            
            <nav>
                
                    <h2><a href="index.html">Documentation</a></h2><div class="category"><h3>Modules</h3><ul><li><a href="module-libs_dataMatrix.html">libs/dataMatrix</a></li><li><a href="module-nock_intercepts.html">nock/intercepts</a></li><li><a href="module-nock_scope.html">nock/scope</a></li><li><a href="module-user.html">user</a></li><li><a href="module-utils_time.html">utils/time</a></li></ul><h3>Namespaces</h3><ul><li><a href="addChainableMethod.html">addChainableMethod</a></li><li><a href="addLengthGuard.html">addLengthGuard</a></li><li><a href="addMethod.html">addMethod</a></li><li><a href="addProperty.html">addProperty</a></li><li><a href="Assert.html">Assert</a></li><li><a href="BDD.html">BDD</a></li><li><a href="expectTypes.html">expectTypes</a></li><li><a href="flag.html">flag</a></li><li><a href="getActual.html">getActual</a></li><li><a href="getEnumerableProperties.html">getEnumerableProperties</a></li><li><a href="getMessage.html">getMessage</a></li><li><a href="getOperator.html">getOperator</a></li><li><a href="getOwnEnumerableProperties.html">getOwnEnumerableProperties</a></li><li><a href="getOwnEnumerablePropertySymbols.html">getOwnEnumerablePropertySymbols</a></li><li><a href="getPathInfo.html">getPathInfo</a></li><li><a href="getPathValue.html">getPathValue</a></li><li><a href="getProperties.html">getProperties</a></li><li><a href="hasProperty.html">hasProperty</a></li><li><a href="global.html#inspect">inspect</a></li><li><a href="isProxyEnabled.html">isProxyEnabled</a></li><li><a href="overwriteChainableMethod.html">overwriteChainableMethod</a></li><li><a href="overwriteMethod.html">overwriteMethod</a></li><li><a href="overwriteProperty.html">overwriteProperty</a></li><li><a href="proxify.html">proxify</a></li><li><a href="Should.html">Should</a></li><li><a href="test.html">test</a></li><li><a href="transferFlags.html">transferFlags</a></li><li><a href="Utils.html">Utils</a></li></ul><h3>Classes</h3><ul><li><a href="App.html">App</a></li><li><a href="Biskviit.html">Biskviit</a></li><li><a href="Client.html">Client</a></li><li><a href="Config.html">Config</a></li><li><a href="Dependencies.html">Dependencies</a></li><li><a href="FetchRequest.html">FetchRequest</a></li><li><a href="Headers.html">Headers</a></li><li><a href="I18n.html">I18n</a></li><li><a href="module.html#.exports">exports</a></li><li><a href="OboeRequest.html">OboeRequest</a></li><li><a href="Request.html">Request</a></li><li><a href="Request_Request.html">Request</a></li><li><a href="RequestChain_RequestChain.html">RequestChain</a></li><li><a href="requests_Request.html">requests/Request</a></li><li><a href="requests_RequestApiMock.html">requests/RequestApiMock</a></li><li><a href="requests_RequestChain.html">requests/RequestChain</a></li><li><a href="requests_RequestSerrea.html">requests/RequestSerrea</a></li><li><a href="Response.html">Response</a></li><li><a href="Section.html">Section</a></li><li><a href="Settings.html">Settings</a></li><li><a href="Tab.html">Tab</a></li><li><a href="TabsBar.html">TabsBar</a></li></ul><h3>Global</h3><ul><li><a href="global.html#_append">_append</a></li><li><a href="global.html#_createHelper">_createHelper</a></li><li><a href="global.html#_createHmacHelper">_createHmacHelper</a></li><li><a href="global.html#_parse">_parse</a></li><li><a href="global.html#_process">_process</a></li><li><a href="global.html#_require$1">_require$1</a></li><li><a href="global.html#_require$2">_require$2</a></li><li><a href="global.html#addToSerie">addToSerie</a></li><li><a href="global.html#aliasToReal">aliasToReal</a></li><li><a href="global.html#anyToString">anyToString</a></li><li><a href="global.html#argsTag">argsTag</a></li><li><a href="global.html#arrayProto">arrayProto</a></li><li><a href="global.html#aryMethod">aryMethod</a></li><li><a href="global.html#aryRearg">aryRearg</a></li><li><a href="global.html#ascentFrom">ascentFrom</a></li><li><a href="global.html#assert">assert</a></li><li><a href="global.html#AssertionError">AssertionError</a></li><li><a href="global.html#asyncTag">asyncTag</a></li><li><a href="global.html#Back">Back</a></li><li><a href="global.html#baseConvert">baseConvert</a></li><li><a href="global.html#Body">Body</a></li><li><a href="global.html#boolTag">boolTag</a></li><li><a href="global.html#browserConvert">browserConvert</a></li><li><a href="global.html#Buffer">Buffer</a></li><li><a href="global.html#buildSerieName">buildSerieName</a></li><li><a href="global.html#byteToHex">byteToHex</a></li><li><a href="global.html#cfg">cfg</a></li><li><a href="global.html#check">check</a></li><li><a href="global.html#checkArray">checkArray</a></li><li><a href="global.html#checkData">checkData</a></li><li><a href="global.html#checkEncoding">checkEncoding</a></li><li><a href="global.html#clamp">clamp</a></li><li><a href="global.html#clone">clone</a></li><li><a href="global.html#CLONE_DEEP_FLAG">CLONE_DEEP_FLAG</a></li><li><a href="global.html#CLONE_SYMBOLS_FLAG">CLONE_SYMBOLS_FLAG</a></li><li><a href="global.html#cloneableTags">cloneableTags</a></li><li><a href="global.html#colors">colors</a></li><li><a href="global.html#COMPARE_PARTIAL_FLAG">COMPARE_PARTIAL_FLAG</a></li><li><a href="global.html#compute">compute</a></li><li><a href="global.html#concat">concat</a></li><li><a href="global.html#consumeBody">consumeBody</a></li><li><a href="global.html#convert">convert</a></li><li><a href="global.html#convertBody">convertBody</a></li><li><a href="global.html#convertIconv">convertIconv</a></li><li><a href="global.html#convertIconvLite">convertIconvLite</a></li><li><a href="global.html#CORE_ERROR_TEXT">CORE_ERROR_TEXT</a></li><li><a href="global.html#coreJsData">coreJsData</a></li><li><a href="global.html#create">create</a></li><li><a href="global.html#createDecryptor">createDecryptor</a></li><li><a href="global.html#createEncryptor">createEncryptor</a></li><li><a href="global.html#createKey">createKey</a></li><li><a href="global.html#dataViewCtorString">dataViewCtorString</a></li><li><a href="global.html#dateTag">dateTag</a></li><li><a href="global.html#deburredLetters">deburredLetters</a></li><li><a href="global.html#decrypt">decrypt</a></li><li><a href="global.html#deepEqual">deepEqual</a></li><li><a href="global.html#deepOwnPropertyVal">deepOwnPropertyVal</a></li><li><a href="global.html#DEFAULT_TRUNC_LENGTH">DEFAULT_TRUNC_LENGTH</a></li><li><a href="global.html#deleteHeadersField">deleteHeadersField</a></li><li><a href="global.html#domExcTag">domExcTag</a></li><li><a href="global.html#eifelerRegelAppliesToNumber">eifelerRegelAppliesToNumber</a></li><li><a href="global.html#encrypt">encrypt</a></li><li><a href="global.html#extend">extend</a></li><li><a href="global.html#extractContentType">extractContentType</a></li><li><a href="global.html#fetch">fetch</a></li><li><a href="global.html#FetchError">FetchError</a></li><li><a href="global.html#finalize">finalize</a></li><li><a href="global.html#fmtLong">fmtLong</a></li><li><a href="global.html#fmtShort">fmtShort</a></li><li><a href="global.html#format">format</a></li><li><a href="global.html#formatArgs">formatArgs</a></li><li><a href="global.html#formatQueryValue">formatQueryValue</a></li><li><a href="global.html#freeExports">freeExports</a></li><li><a href="global.html#freeGlobal">freeGlobal</a></li><li><a href="global.html#freeModule">freeModule</a></li><li><a href="global.html#freeParseFloat">freeParseFloat</a></li><li><a href="global.html#freeParseInt">freeParseInt</a></li><li><a href="global.html#freeProcess">freeProcess</a></li><li><a href="global.html#freeSelf">freeSelf</a></li><li><a href="global.html#fromCsv">fromCsv</a></li><li><a href="global.html#fromJson">fromJson</a></li><li><a href="global.html#fromJsonCompact">fromJsonCompact</a></li><li><a href="global.html#fromNone">fromNone</a></li><li><a href="global.html#FUNC_ERROR_TEXT">FUNC_ERROR_TEXT</a></li><li><a href="global.html#funcProto">funcProto</a></li><li><a href="global.html#funcToString">funcToString</a></li><li><a href="global.html#generateSeries">generateSeries</a></li><li><a href="global.html#getDate">getDate</a></li><li><a href="global.html#getGenericData">getGenericData</a></li><li><a href="global.html#getNodeRequestOptions">getNodeRequestOptions</a></li><li><a href="global.html#getPrototype">getPrototype</a></li><li><a href="global.html#getSign">getSign</a></li><li><a href="global.html#getTotalBytes">getTotalBytes</a></li><li><a href="global.html#HASH_UNDEFINED">HASH_UNDEFINED</a></li><li><a href="global.html#hasOwnProperty">hasOwnProperty</a></li><li><a href="global.html#HOT_COUNT">HOT_COUNT</a></li><li><a href="global.html#htmlEscapes">htmlEscapes</a></li><li><a href="global.html#htmlUnescapes">htmlUnescapes</a></li><li><a href="global.html#http">http</a></li><li><a href="global.html#idCounter">idCounter</a></li><li><a href="global.html#INFINITY">INFINITY</a></li><li><a href="global.html#init">init</a></li><li><a href="global.html#inspectOpts">inspectOpts</a></li><li><a href="global.html#INVALID_TEMPL_VAR_ERROR_TEXT">INVALID_TEMPL_VAR_ERROR_TEXT</a></li><li><a href="global.html#isBinaryBuffer">isBinaryBuffer</a></li><li><a href="global.html#isNaN">isNaN</a></li><li><a href="global.html#isRequest">isRequest</a></li><li><a href="global.html#isURLSearchParams">isURLSearchParams</a></li><li><a href="global.html#iterateeAry">iterateeAry</a></li><li><a href="global.html#iterateeRearg">iterateeRearg</a></li><li><a href="global.html#LARGE_ARRAY_SIZE">LARGE_ARRAY_SIZE</a></li><li><a href="global.html#LAZY_FILTER_FLAG">LAZY_FILTER_FLAG</a></li><li><a href="global.html#load">load</a></li><li><a href="global.html#localstorage">localstorage</a></li><li><a href="global.html#log">log</a></li><li><a href="global.html#mapTag">mapTag</a></li><li><a href="global.html#mapValuesDeep">mapValuesDeep</a></li><li><a href="global.html#maskSrcKey">maskSrcKey</a></li><li><a href="global.html#MAX_ARRAY_LENGTH">MAX_ARRAY_LENGTH</a></li><li><a href="global.html#MAX_MEMOIZE_SIZE">MAX_MEMOIZE_SIZE</a></li><li><a href="global.html#MAX_SAFE_INTEGER">MAX_SAFE_INTEGER</a></li><li><a href="global.html#mergeChunks">mergeChunks</a></li><li><a href="global.html#metaMap">metaMap</a></li><li><a href="global.html#methodRearg">methodRearg</a></li><li><a href="global.html#methodSpread">methodSpread</a></li><li><a href="global.html#mixIn">mixIn</a></li><li><a href="global.html#moduleExports">moduleExports</a></li><li><a href="global.html#mutate">mutate</a></li><li><a href="global.html#NAN">NAN</a></li><li><a href="global.html#nativeObjectToString">nativeObjectToString</a></li><li><a href="global.html#nodeUtil">nodeUtil</a></li><li><a href="global.html#normalizeRequestOptions">normalizeRequestOptions</a></li><li><a href="global.html#notDeepOwnPropertyVal">notDeepOwnPropertyVal</a></li><li><a href="global.html#notOwnProperty">notOwnProperty</a></li><li><a href="global.html#notOwnPropertyVal">notOwnPropertyVal</a></li><li><a href="global.html#nullTag">nullTag</a></li><li><a href="global.html#numberTag">numberTag</a></li><li><a href="global.html#objectCreate">objectCreate</a></li><li><a href="global.html#objectCtorString">objectCtorString</a></li><li><a href="global.html#objectProto">objectProto</a></li><li><a href="global.html#objectTag">objectTag</a></li><li><a href="global.html#on">on</a></li><li><a href="global.html#once">once</a></li><li><a href="global.html#overrideRequests">overrideRequests</a></li><li><a href="global.html#ownProperty">ownProperty</a></li><li><a href="global.html#ownPropertyVal">ownPropertyVal</a></li><li><a href="global.html#param">param</a></li><li><a href="global.html#parse">parse</a></li><li><a href="global.html#parseDateToEpoch">parseDateToEpoch</a></li><li><a href="global.html#parseTemplate">parseTemplate</a></li><li><a href="global.html#PLACEHOLDER">PLACEHOLDER</a></li><li><a href="global.html#plural">plural</a></li><li><a href="global.html#process">process</a></li><li><a href="global.html#processBlock">processBlock</a></li><li><a href="global.html#processSeries">processSeries</a></li><li><a href="global.html#processValues">processValues</a></li><li><a href="global.html#propertyIsEnumerable">propertyIsEnumerable</a></li><li><a href="global.html#punycode">punycode</a></li><li><a href="global.html#push">push</a></li><li><a href="global.html#query">query</a></li><li><a href="global.html#random">random</a></li><li><a href="global.html#realNames">realNames</a></li><li><a href="global.html#realToAlias">realToAlias</a></li><li><a href="global.html#reApos">reApos</a></li><li><a href="global.html#reAsciiWord">reAsciiWord</a></li><li><a href="global.html#reComboMark">reComboMark</a></li><li><a href="global.html#reEmptyStringLeading">reEmptyStringLeading</a></li><li><a href="global.html#reEscape">reEscape</a></li><li><a href="global.html#reEscapeChar">reEscapeChar</a></li><li><a href="global.html#reEscapedHtml">reEscapedHtml</a></li><li><a href="global.html#reEsTemplate">reEsTemplate</a></li><li><a href="global.html#reEvaluate">reEvaluate</a></li><li><a href="global.html#reFlags">reFlags</a></li><li><a href="global.html#reForbiddenIdentifierChars">reForbiddenIdentifierChars</a></li><li><a href="global.html#regexpTag">regexpTag</a></li><li><a href="global.html#reHasUnicode">reHasUnicode</a></li><li><a href="global.html#reHasUnicodeWord">reHasUnicodeWord</a></li><li><a href="global.html#reInterpolate">reInterpolate</a></li><li><a href="global.html#reIsBadHex">reIsBadHex</a></li><li><a href="global.html#reIsBinary">reIsBinary</a></li><li><a href="global.html#reIsDeepProp">reIsDeepProp</a></li><li><a href="global.html#reIsHostCtor">reIsHostCtor</a></li><li><a href="global.html#reIsNative">reIsNative</a></li><li><a href="global.html#reIsOctal">reIsOctal</a></li><li><a href="global.html#reIsUint">reIsUint</a></li><li><a href="global.html#reLatin">reLatin</a></li><li><a href="global.html#remap">remap</a></li><li><a href="global.html#reNoMatch">reNoMatch</a></li><li><a href="global.html#reOptMod">reOptMod</a></li><li><a href="global.html#reportArgumentsToCallback">reportArgumentsToCallback</a></li><li><a href="global.html#rePropName">rePropName</a></li><li><a href="global.html#reRegExpChar">reRegExpChar</a></li><li><a href="global.html#reset">reset</a></li><li><a href="global.html#restoreOverriddenRequests">restoreOverriddenRequests</a></li><li><a href="global.html#reTrimStart">reTrimStart</a></li><li><a href="global.html#returnNoData">returnNoData</a></li><li><a href="global.html#reUnescapedHtml">reUnescapedHtml</a></li><li><a href="global.html#reUnescapedString">reUnescapedString</a></li><li><a href="global.html#reUnicode">reUnicode</a></li><li><a href="global.html#reUnicodeWord">reUnicodeWord</a></li><li><a href="global.html#reWhitespace">reWhitespace</a></li><li><a href="global.html#reWrapComment">reWrapComment</a></li><li><a href="global.html#reWrapDetails">reWrapDetails</a></li><li><a href="global.html#root">root</a></li><li><a href="global.html#rsApos">rsApos</a></li><li><a href="global.html#rsAstral">rsAstral</a></li><li><a href="global.html#rsAstralRange">rsAstralRange</a></li><li><a href="global.html#rsCombo">rsCombo</a></li><li><a href="global.html#rsComboMarksRange">rsComboMarksRange</a></li><li><a href="global.html#rsMiscLower">rsMiscLower</a></li><li><a href="global.html#rsZWJ">rsZWJ</a></li><li><a href="global.html#s">s</a></li><li><a href="global.html#sanitizeName">sanitizeName</a></li><li><a href="global.html#save">save</a></li><li><a href="global.html#setPathValue">setPathValue</a></li><li><a href="global.html#setTag">setTag</a></li><li><a href="global.html#setTimeout">setTimeout</a></li><li><a href="global.html#setup">setup</a></li><li><a href="global.html#simpleEqual">simpleEqual</a></li><li><a href="global.html#sinon">sinon</a></li><li><a href="global.html#skipFixed">skipFixed</a></li><li><a href="global.html#skipRearg">skipRearg</a></li><li><a href="global.html#splice">splice</a></li><li><a href="global.html#spreadableSymbol">spreadableSymbol</a></li><li><a href="global.html#Stream">Stream</a></li><li><a href="global.html#stringDistanceCapped">stringDistanceCapped</a></li><li><a href="global.html#stringEscapes">stringEscapes</a></li><li><a href="global.html#stringifyRequest">stringifyRequest</a></li><li><a href="global.html#stringTag">stringTag</a></li><li><a href="global.html#stringToPath">stringToPath</a></li><li><a href="global.html#Symbol">Symbol</a></li><li><a href="global.html#symbolProto">symbolProto</a></li><li><a href="global.html#symbolTag">symbolTag</a></li><li><a href="global.html#symIterator">symIterator</a></li><li><a href="global.html#symToStringTag">symToStringTag</a></li><li><a href="global.html#thrice">thrice</a></li><li><a href="global.html#times">times</a></li><li><a href="global.html#toString">toString</a></li><li><a href="global.html#toUrl">toUrl</a></li><li><a href="global.html#toX32">toX32</a></li><li><a href="global.html#tty">tty</a></li><li><a href="global.html#twice">twice</a></li><li><a href="global.html#typedArrayTags">typedArrayTags</a></li><li><a href="global.html#Uint8Array">Uint8Array</a></li><li><a href="global.html#UNEWTRIE2_DATA_0800_OFFSET">UNEWTRIE2_DATA_0800_OFFSET</a></li><li><a href="global.html#UNEWTRIE2_DATA_NULL_OFFSET">UNEWTRIE2_DATA_NULL_OFFSET</a></li><li><a href="global.html#UNEWTRIE2_DATA_START_OFFSET">UNEWTRIE2_DATA_START_OFFSET</a></li><li><a href="global.html#UNEWTRIE2_INDEX_2_NULL_OFFSET">UNEWTRIE2_INDEX_2_NULL_OFFSET</a></li><li><a href="global.html#UNEWTRIE2_INDEX_2_START_OFFSET">UNEWTRIE2_INDEX_2_START_OFFSET</a></li><li><a href="global.html#UNEWTRIE2_MAX_DATA_LENGTH">UNEWTRIE2_MAX_DATA_LENGTH</a></li><li><a href="global.html#UNEWTRIE2_MAX_INDEX_2_LENGTH">UNEWTRIE2_MAX_INDEX_2_LENGTH</a></li><li><a href="global.html#update">update</a></li><li><a href="global.html#use">use</a></li><li><a href="global.html#useColors">useColors</a></li><li><a href="global.html#UTRIE2_BAD_UTF8_DATA_OFFSET">UTRIE2_BAD_UTF8_DATA_OFFSET</a></li><li><a href="global.html#UTRIE2_CP_PER_INDEX_1_ENTRY">UTRIE2_CP_PER_INDEX_1_ENTRY</a></li><li><a href="global.html#UTRIE2_DATA_BLOCK_LENGTH">UTRIE2_DATA_BLOCK_LENGTH</a></li><li><a href="global.html#UTRIE2_DATA_BLOCK_LENGTH$1">UTRIE2_DATA_BLOCK_LENGTH$1</a></li><li><a href="global.html#UTRIE2_DATA_GRANULARITY">UTRIE2_DATA_GRANULARITY</a></li><li><a href="global.html#UTRIE2_DATA_MASK">UTRIE2_DATA_MASK</a></li><li><a href="global.html#UTRIE2_DATA_MASK$1">UTRIE2_DATA_MASK$1</a></li><li><a href="global.html#UTRIE2_DATA_START_OFFSET">UTRIE2_DATA_START_OFFSET</a></li><li><a href="global.html#UTRIE2_INDEX_1_OFFSET">UTRIE2_INDEX_1_OFFSET</a></li><li><a href="global.html#UTRIE2_INDEX_1_OFFSET$1">UTRIE2_INDEX_1_OFFSET$1</a></li><li><a href="global.html#UTRIE2_INDEX_2_BLOCK_LENGTH">UTRIE2_INDEX_2_BLOCK_LENGTH</a></li><li><a href="global.html#UTRIE2_INDEX_2_BLOCK_LENGTH$1">UTRIE2_INDEX_2_BLOCK_LENGTH$1</a></li><li><a href="global.html#UTRIE2_INDEX_2_BMP_LENGTH">UTRIE2_INDEX_2_BMP_LENGTH</a></li><li><a href="global.html#UTRIE2_INDEX_2_BMP_LENGTH$1">UTRIE2_INDEX_2_BMP_LENGTH$1</a></li><li><a href="global.html#UTRIE2_INDEX_2_MASK">UTRIE2_INDEX_2_MASK</a></li><li><a href="global.html#UTRIE2_INDEX_2_MASK$1">UTRIE2_INDEX_2_MASK$1</a></li><li><a href="global.html#UTRIE2_INDEX_2_OFFSET">UTRIE2_INDEX_2_OFFSET</a></li><li><a href="global.html#UTRIE2_INDEX_SHIFT">UTRIE2_INDEX_SHIFT</a></li><li><a href="global.html#UTRIE2_INDEX_SHIFT$1">UTRIE2_INDEX_SHIFT$1</a></li><li><a href="global.html#UTRIE2_LSCP_INDEX_2_OFFSET">UTRIE2_LSCP_INDEX_2_OFFSET</a></li><li><a href="global.html#UTRIE2_LSCP_INDEX_2_OFFSET$1">UTRIE2_LSCP_INDEX_2_OFFSET$1</a></li><li><a href="global.html#UTRIE2_MAX_DATA_LENGTH">UTRIE2_MAX_DATA_LENGTH</a></li><li><a href="global.html#UTRIE2_MAX_INDEX_LENGTH">UTRIE2_MAX_INDEX_LENGTH</a></li><li><a href="global.html#UTRIE2_OMITTED_BMP_INDEX_1_LENGTH">UTRIE2_OMITTED_BMP_INDEX_1_LENGTH</a></li><li><a href="global.html#UTRIE2_OMITTED_BMP_INDEX_1_LENGTH$1">UTRIE2_OMITTED_BMP_INDEX_1_LENGTH$1</a></li><li><a href="global.html#UTRIE2_SHIFT_1">UTRIE2_SHIFT_1</a></li><li><a href="global.html#UTRIE2_SHIFT_1$1">UTRIE2_SHIFT_1$1</a></li><li><a href="global.html#UTRIE2_SHIFT_1_2">UTRIE2_SHIFT_1_2</a></li><li><a href="global.html#UTRIE2_SHIFT_1_2$1">UTRIE2_SHIFT_1_2$1</a></li><li><a href="global.html#UTRIE2_SHIFT_2">UTRIE2_SHIFT_2</a></li><li><a href="global.html#UTRIE2_SHIFT_2$1">UTRIE2_SHIFT_2$1</a></li><li><a href="global.html#UTRIE2_UTF8_2B_INDEX_2_OFFSET">UTRIE2_UTF8_2B_INDEX_2_OFFSET</a></li><li><a href="global.html#UTRIE2_UTF8_2B_INDEX_2_OFFSET$1">UTRIE2_UTF8_2B_INDEX_2_OFFSET$1</a></li><li><a href="global.html#validate">validate</a></li><li><a href="global.html#weakMapTag">weakMapTag</a></li><li><a href="global.html#weakSetTag">weakSetTag</a></li><li><a href="global.html#WRAP_ARY_FLAG">WRAP_ARY_FLAG</a></li><li><a href="global.html#WRAP_BIND_FLAG">WRAP_BIND_FLAG</a></li><li><a href="global.html#WRAP_CURRY_FLAG">WRAP_CURRY_FLAG</a></li><li><a href="global.html#WRAP_CURRY_RIGHT_FLAG">WRAP_CURRY_RIGHT_FLAG</a></li><li><a href="global.html#WRAP_FLIP_FLAG">WRAP_FLIP_FLAG</a></li><li><a href="global.html#WRAP_PARTIAL_FLAG">WRAP_PARTIAL_FLAG</a></li><li><a href="global.html#WRAP_PARTIAL_RIGHT_FLAG">WRAP_PARTIAL_RIGHT_FLAG</a></li><li><a href="global.html#WRAP_REARG_FLAG">WRAP_REARG_FLAG</a></li><li><a href="global.html#wrapFlags">wrapFlags</a></li><li><a href="global.html#writeToStream">writeToStream</a></li><li><a href="global.html#XDomainRequest">XDomainRequest</a></li><li><a href="global.html#XMLHttpRequest">XMLHttpRequest</a></li><li><a href="global.html#zeroFill">zeroFill</a></li></ul></div><div class="category"><h2>Data</h2><h3>Classes</h3><ul><li><a href="DataNode.html">DataNode</a></li><li><a href="DataTree.html">DataTree</a></li><li><a href="Dependencies.html">Dependencies</a></li><li><a href="Requests.html">Requests</a></li></ul></div><div class="category"><h2>Fields</h2><h3>Classes</h3><ul><li><a href="BaseField.html">BaseField</a></li><li><a href="Button.html">Button</a></li><li><a href="CheckBoxField.html">CheckBoxField</a></li><li><a href="ChoicePickerField.html">ChoicePickerField</a></li><li><a href="DateTimePickerField.html">DateTimePickerField</a></li><li><a href="DateTimePickerRangeField.html">DateTimePickerRangeField</a></li><li><a href="DateTimePickerRangeFieldPresets.html">DateTimePickerRangeFieldPresets</a></li><li><a href="InputField.html">InputField</a></li><li><a href="Select2Field.html">Select2Field</a></li><li><a href="SelectField.html">SelectField</a></li></ul><h3>Global</h3><ul><li><a href="global.html#matchElement">matchElement</a></li></ul></div><div class="category"><h2>Libs</h2><h3>Modules</h3><ul><li><a href="module-alerts.html">alerts</a></li><li><a href="module-D3Bullet.html">D3Bullet</a></li><li><a href="module-dom.html">dom</a></li><li><a href="module-downloads.html">downloads</a></li><li><a href="module-events.html">events</a></li><li><a href="module-user.html">user</a></li><li><a href="module-zoomChart.html">zoomChart</a></li></ul><h3>Classes</h3><ul><li><a href="ScreenShot.html">ScreenShot</a></li></ul><h3>Global</h3><ul><li><a href="global.html#takeElementScreenShot">takeElementScreenShot</a></li></ul></div><div class="category"><h2>Seq</h2><h3>Classes</h3><ul><li><a href="-_.html">_</a></li></ul></div><div class="category"><h2>Utils</h2><h3>Modules / Bootstrap</h3><ul><li><a href="module-bootstrap.html">bootstrap</a></li></ul><h3>Modules / Global</h3><ul><li><a href="module-casting.html">casting</a></li><li><a href="module-dateRange.html">dateRange</a></li><li><a href="module-dates.html">dates</a></li><li><a href="module-intervals.html">intervals</a></li><li><a href="module-objects.html">objects</a></li><li><a href="module-order.html">order</a></li><li><a href="module-Query%2520Utils.html">Query Utils</a></li><li><a href="module-scroll.html">scroll</a></li><li><a href="module-units.html">units</a></li></ul><h3>Modules / Helpers</h3><ul><li><a href="module-Helper%2520Highcharts.html">Helper Highcharts</a></li><li><a href="module-Helper%2520Renderers.html">Helper Renderers</a></li></ul><h3>Classes / Bootstrap</h3><ul><li><a href="FullScreenShotBtn.html">FullScreenShotBtn</a></li><li><a href="TvBtn.html">TvBtn</a></li></ul><h3>Classes / Helpers</h3><ul><li><a href="Monitoring.html">Monitoring</a></li></ul></div><div class="category"><h2>Widgets</h2><h3>Modules</h3><ul><li><a href="module-AnimatedHeatmap.html">AnimatedHeatmap</a></li><li><a href="module-Area.html">Area</a></li><li><a href="module-AvailabilityTimeline.html">AvailabilityTimeline</a></li><li><a href="module-Bichord.html">Bichord</a></li><li><a href="module-Bubbles.html">Bubbles</a></li><li><a href="module-Bullet.html">Bullet</a></li><li><a href="module-CircleWorldMap.html">CircleWorldMap</a></li><li><a href="module-Column.html">Column</a></li><li><a href="module-Empty.html">Empty</a></li><li><a href="module-Funnel.html">Funnel</a></li><li><a href="module-Gauge.html">Gauge</a></li><li><a href="module-GoogleColormap.html">GoogleColormap</a></li><li><a href="module-GoogleHeatmap.html">GoogleHeatmap</a></li><li><a href="module-Graph.html">Graph</a></li><li><a href="module-HeatCalendar.html">HeatCalendar</a></li><li><a href="module-Histogram.html">Histogram</a></li><li><a href="module-Lines.html">Lines</a></li><li><a href="module-Monitoring.html">Monitoring</a></li><li><a href="module-PewPewMap.html">PewPewMap</a></li><li><a href="module-Pie.html">Pie</a></li><li><a href="module-PieLayered.html">PieLayered</a></li><li><a href="module-Punchcard.html">Punchcard</a></li><li><a href="module-RAG.html">RAG</a></li><li><a href="module-Sankey.html">Sankey</a></li><li><a href="module-Series.html">Series</a></li><li><a href="module-StackedBars.html">StackedBars</a></li><li><a href="module-Table.html">Table</a></li><li><a href="module-TimeHeatmap.html">TimeHeatmap</a></li><li><a href="module-Tree.html">Tree</a></li><li><a href="module-Voronoi.html">Voronoi</a></li></ul><h3>Modules / Mixins</h3><ul><li><a href="module-base.html">base</a></li><li><a href="module-collapser.html">collapser</a></li><li><a href="module-dataSearch.html">dataSearch</a></li><li><a href="module-download.html">download</a></li><li><a href="module-info.html">info</a></li><li><a href="module-lifeCycle.html">lifeCycle</a></li><li><a href="module-listeners.html">listeners</a></li><li><a href="module-loading.html">loading</a></li><li><a href="module-menu.html">menu</a></li><li><a href="module-screenshot.html">screenshot</a></li><li><a href="module-showQuery.html">showQuery</a></li><li><a href="module-zoom.html">zoom</a></li></ul></div>
                
            </nav>
        </div>
        <div class="core" id="main-content-wrapper">
            <div class="content">
                <header class="page-title">
                    <p>Namespace</p>
                    <h1>BDD</h1>
                </header>
                




<section>

<header>
    
        <h2>BDD</h2>
        
    
</header>

<article>
    <div class="container-overview">
    
        
            <div class="description"><h3>Language Chains</h3>
<p>The following are provided as chainable getters to improve the readability
of your assertions.</p>
<p><strong>Chains</strong></p>
<ul>
<li>to</li>
<li>be</li>
<li>been</li>
<li>is</li>
<li>that</li>
<li>which</li>
<li>and</li>
<li>has</li>
<li>have</li>
<li>with</li>
<li>at</li>
<li>of</li>
<li>same</li>
<li>but</li>
<li>does</li>
<li>still</li>
<li>also</li>
</ul></div>
        

        


<dl class="details">

    

    

    

    

    

    

    

    

    

    

    

    
    

    

    

    
        <p class="tag-source">
            <a href="node_modules_chai_chai.js.html" class="button">View Source</a>
            <span>
                <a href="node_modules_chai_chai.js.html">node_modules/chai/chai.js</a>, <a href="node_modules_chai_chai.js.html#line384">line 384</a>
            </span>
        </p>
    
</dl>


        
    
    </div>
    
    

    

    

    

    

    

    

    

    

    
</article>

</section>







<section>

<header>
    
        <h2>BDD</h2>
        
    
</header>

<article>
    <div class="container-overview">
    
        
            <div class="description"><h3>.not</h3>
<p>Negates all assertions that follow in the chain.</p>
<pre><code>expect(function () {}).to.not.throw();
expect({a: 1}).to.not.have.property('b');
expect([1, 2]).to.be.an('array').that.does.not.include(3);
</code></pre>
<p>Just because you can negate any assertion with <code>.not</code> doesn't mean you
should. With great power comes great responsibility. It's often best to
assert that the one expected output was produced, rather than asserting
that one of countless unexpected outputs wasn't produced. See individual
assertions for specific guidance.</p>
<pre><code>expect(2).to.equal(2); // Recommended
expect(2).to.not.equal(1); // Not recommended</code></pre></div>
        

        


<dl class="details">

    

    

    

    

    

    

    

    

    

    

    

    
    

    

    

    
        <p class="tag-source">
            <a href="node_modules_chai_chai.js.html" class="button">View Source</a>
            <span>
                <a href="node_modules_chai_chai.js.html">node_modules/chai/chai.js</a>, <a href="node_modules_chai_chai.js.html#line422">line 422</a>
            </span>
        </p>
    
</dl>


        
    
    </div>
    
    

    

    

    

    

    

    

    

    

    
</article>

</section>







<section>

<header>
    
        <h2>BDD</h2>
        
    
</header>

<article>
    <div class="container-overview">
    
        
            <div class="description"><h3>.deep</h3>
<p>Causes all <code>.equal</code>, <code>.include</code>, <code>.members</code>, <code>.keys</code>, and <code>.property</code>
assertions that follow in the chain to use deep equality instead of strict
(<code>===</code>) equality. See the <code>deep-eql</code> project page for info on the deep
equality algorithm: https://github.com/chaijs/deep-eql.</p>
<pre><code>// Target object deeply (but not strictly) equals `{a: 1}`
expect({a: 1}).to.deep.equal({a: 1});
expect({a: 1}).to.not.equal({a: 1});

// Target array deeply (but not strictly) includes `{a: 1}`
expect([{a: 1}]).to.deep.include({a: 1});
expect([{a: 1}]).to.not.include({a: 1});

// Target object deeply (but not strictly) includes `x: {a: 1}`
expect({x: {a: 1}}).to.deep.include({x: {a: 1}});
expect({x: {a: 1}}).to.not.include({x: {a: 1}});

// Target array deeply (but not strictly) has member `{a: 1}`
expect([{a: 1}]).to.have.deep.members([{a: 1}]);
expect([{a: 1}]).to.not.have.members([{a: 1}]);

// Target set deeply (but not strictly) has key `{a: 1}`
expect(new Set([{a: 1}])).to.have.deep.keys([{a: 1}]);
expect(new Set([{a: 1}])).to.not.have.keys([{a: 1}]);

// Target object deeply (but not strictly) has property `x: {a: 1}`
expect({x: {a: 1}}).to.have.deep.property('x', {a: 1});
expect({x: {a: 1}}).to.not.have.property('x', {a: 1});</code></pre></div>
        

        


<dl class="details">

    

    

    

    

    

    

    

    

    

    

    

    
    

    

    

    
        <p class="tag-source">
            <a href="node_modules_chai_chai.js.html" class="button">View Source</a>
            <span>
                <a href="node_modules_chai_chai.js.html">node_modules/chai/chai.js</a>, <a href="node_modules_chai_chai.js.html#line449">line 449</a>
            </span>
        </p>
    
</dl>


        
    
    </div>
    
    

    

    

    

    

    

    

    

    

    
</article>

</section>







<section>

<header>
    
        <h2>BDD</h2>
        
    
</header>

<article>
    <div class="container-overview">
    
        
            <div class="description"><h3>.nested</h3>
<p>Enables dot- and bracket-notation in all <code>.property</code> and <code>.include</code>
assertions that follow in the chain.</p>
<pre><code>expect({a: {b: ['x', 'y']}}).to.have.nested.property('a.b[1]');
expect({a: {b: ['x', 'y']}}).to.nested.include({'a.b[1]': 'y'});
</code></pre>
<p>If <code>.</code> or <code>[]</code> are part of an actual property name, they can be escaped by
adding two backslashes before them.</p>
<pre><code>expect({'.a': {'[b]': 'x'}}).to.have.nested.property('\\.a.\\[b\\]');
expect({'.a': {'[b]': 'x'}}).to.nested.include({'\\.a.\\[b\\]': 'x'});
</code></pre>
<p><code>.nested</code> cannot be combined with <code>.own</code>.</p></div>
        

        


<dl class="details">

    

    

    

    

    

    

    

    

    

    

    

    
    

    

    

    
        <p class="tag-source">
            <a href="node_modules_chai_chai.js.html" class="button">View Source</a>
            <span>
                <a href="node_modules_chai_chai.js.html">node_modules/chai/chai.js</a>, <a href="node_modules_chai_chai.js.html#line490">line 490</a>
            </span>
        </p>
    
</dl>


        
    
    </div>
    
    

    

    

    

    

    

    

    

    

    
</article>

</section>







<section>

<header>
    
        <h2>BDD</h2>
        
    
</header>

<article>
    <div class="container-overview">
    
        
            <div class="description"><h3>.own</h3>
<p>Causes all <code>.property</code> and <code>.include</code> assertions that follow in the chain
to ignore inherited properties.</p>
<pre><code>Object.prototype.b = 2;

expect({a: 1}).to.have.own.property('a');
expect({a: 1}).to.have.property('b');
expect({a: 1}).to.not.have.own.property('b');

expect({a: 1}).to.own.include({a: 1});
expect({a: 1}).to.include({b: 2}).but.not.own.include({b: 2});
</code></pre>
<p><code>.own</code> cannot be combined with <code>.nested</code>.</p></div>
        

        


<dl class="details">

    

    

    

    

    

    

    

    

    

    

    

    
    

    

    

    
        <p class="tag-source">
            <a href="node_modules_chai_chai.js.html" class="button">View Source</a>
            <span>
                <a href="node_modules_chai_chai.js.html">node_modules/chai/chai.js</a>, <a href="node_modules_chai_chai.js.html#line516">line 516</a>
            </span>
        </p>
    
</dl>


        
    
    </div>
    
    

    

    

    

    

    

    

    

    

    
</article>

</section>







<section>

<header>
    
        <h2>BDD</h2>
        
    
</header>

<article>
    <div class="container-overview">
    
        
            <div class="description"><h3>.ordered</h3>
<p>Causes all <code>.members</code> assertions that follow in the chain to require that
members be in the same order.</p>
<pre><code>expect([1, 2]).to.have.ordered.members([1, 2])
  .but.not.have.ordered.members([2, 1]);
</code></pre>
<p>When <code>.include</code> and <code>.ordered</code> are combined, the ordering begins at the
start of both arrays.</p>
<pre><code>expect([1, 2, 3]).to.include.ordered.members([1, 2])
  .but.not.include.ordered.members([2, 3]);</code></pre></div>
        

        


<dl class="details">

    

    

    

    

    

    

    

    

    

    

    

    
    

    

    

    
        <p class="tag-source">
            <a href="node_modules_chai_chai.js.html" class="button">View Source</a>
            <span>
                <a href="node_modules_chai_chai.js.html">node_modules/chai/chai.js</a>, <a href="node_modules_chai_chai.js.html#line542">line 542</a>
            </span>
        </p>
    
</dl>


        
    
    </div>
    
    

    

    

    

    

    

    

    

    

    
</article>

</section>







<section>

<header>
    
        <h2>BDD</h2>
        
    
</header>

<article>
    <div class="container-overview">
    
        
            <div class="description"><h3>.any</h3>
<p>Causes all <code>.keys</code> assertions that follow in the chain to only require that
the target have at least one of the given keys. This is the opposite of
<code>.all</code>, which requires that the target have all of the given keys.</p>
<pre><code>expect({a: 1, b: 2}).to.not.have.any.keys('c', 'd');
</code></pre>
<p>See the <code>.keys</code> doc for guidance on when to use <code>.any</code> or <code>.all</code>.</p></div>
        

        


<dl class="details">

    

    

    

    

    

    

    

    

    

    

    

    
    

    

    

    
        <p class="tag-source">
            <a href="node_modules_chai_chai.js.html" class="button">View Source</a>
            <span>
                <a href="node_modules_chai_chai.js.html">node_modules/chai/chai.js</a>, <a href="node_modules_chai_chai.js.html#line566">line 566</a>
            </span>
        </p>
    
</dl>


        
    
    </div>
    
    

    

    

    

    

    

    

    

    

    
</article>

</section>







<section>

<header>
    
        <h2>BDD</h2>
        
    
</header>

<article>
    <div class="container-overview">
    
        
            <div class="description"><h3>.all</h3>
<p>Causes all <code>.keys</code> assertions that follow in the chain to require that the
target have all of the given keys. This is the opposite of <code>.any</code>, which
only requires that the target have at least one of the given keys.</p>
<pre><code>expect({a: 1, b: 2}).to.have.all.keys('a', 'b');
</code></pre>
<p>Note that <code>.all</code> is used by default when neither <code>.all</code> nor <code>.any</code> are
added earlier in the chain. However, it's often best to add <code>.all</code> anyway
because it improves readability.</p>
<p>See the <code>.keys</code> doc for guidance on when to use <code>.any</code> or <code>.all</code>.</p></div>
        

        


<dl class="details">

    

    

    

    

    

    

    

    

    

    

    

    
    

    

    

    
        <p class="tag-source">
            <a href="node_modules_chai_chai.js.html" class="button">View Source</a>
            <span>
                <a href="node_modules_chai_chai.js.html">node_modules/chai/chai.js</a>, <a href="node_modules_chai_chai.js.html#line587">line 587</a>
            </span>
        </p>
    
</dl>


        
    
    </div>
    
    

    

    

    

    

    

    

    

    

    
</article>

</section>







<section>

<header>
    
        <h2>BDD</h2>
        
    
</header>

<article>
    <div class="container-overview">
    
        
            <div class="description"><h3>.a(type[, msg])</h3>
<p>Asserts that the target's type is equal to the given string <code>type</code>. Types
are case insensitive. See the <code>type-detect</code> project page for info on the
type detection algorithm: https://github.com/chaijs/type-detect.</p>
<pre><code>expect('foo').to.be.a('string');
expect({a: 1}).to.be.an('object');
expect(null).to.be.a('null');
expect(undefined).to.be.an('undefined');
expect(new Error).to.be.an('error');
expect(Promise.resolve()).to.be.a('promise');
expect(new Float32Array).to.be.a('float32array');
expect(Symbol()).to.be.a('symbol');
</code></pre>
<p><code>.a</code> supports objects that have a custom type set via <code>Symbol.toStringTag</code>.</p>
<pre><code>var myObj = {
  [Symbol.toStringTag]: 'myCustomType'
};

expect(myObj).to.be.a('myCustomType').but.not.an('object');
</code></pre>
<p>It's often best to use <code>.a</code> to check a target's type before making more
assertions on the same target. That way, you avoid unexpected behavior from
any assertion that does different things based on the target's type.</p>
<pre><code>expect([1, 2, 3]).to.be.an('array').that.includes(2);
expect([]).to.be.an('array').that.is.empty;
</code></pre>
<p>Add <code>.not</code> earlier in the chain to negate <code>.a</code>. However, it's often best to
assert that the target is the expected type, rather than asserting that it
isn't one of many unexpected types.</p>
<pre><code>expect('foo').to.be.a('string'); // Recommended
expect('foo').to.not.be.an('array'); // Not recommended
</code></pre>
<p><code>.a</code> accepts an optional <code>msg</code> argument which is a custom error message to
show when the assertion fails. The message can also be given as the second
argument to <code>expect</code>.</p>
<pre><code>expect(1).to.be.a('string', 'nooo why fail??');
expect(1, 'nooo why fail??').to.be.a('string');
</code></pre>
<p><code>.a</code> can also be used as a language chain to improve the readability of
your assertions.</p>
<pre><code>expect({b: 2}).to.have.a.property('b');
</code></pre>
<p>The alias <code>.an</code> can be used interchangeably with <code>.a</code>.</p></div>
        

        


<dl class="details">

    

    

    

    

    

    

    

    

    

    

    

    
    

    

    

    
        <p class="tag-source">
            <a href="node_modules_chai_chai.js.html" class="button">View Source</a>
            <span>
                <a href="node_modules_chai_chai.js.html">node_modules/chai/chai.js</a>, <a href="node_modules_chai_chai.js.html#line612">line 612</a>
            </span>
        </p>
    
</dl>


        
    
    </div>
    
    

    

    

    

    

    

    

    

    

    
</article>

</section>







<section>

<header>
    
        <h2>BDD</h2>
        
    
</header>

<article>
    <div class="container-overview">
    
        
            <div class="description"><h3>.include(val[, msg])</h3>
<p>When the target is a string, <code>.include</code> asserts that the given string <code>val</code>
is a substring of the target.</p>
<pre><code>expect('foobar').to.include('foo');
</code></pre>
<p>When the target is an array, <code>.include</code> asserts that the given <code>val</code> is a
member of the target.</p>
<pre><code>expect([1, 2, 3]).to.include(2);
</code></pre>
<p>When the target is an object, <code>.include</code> asserts that the given object
<code>val</code>'s properties are a subset of the target's properties.</p>
<pre><code>expect({a: 1, b: 2, c: 3}).to.include({a: 1, b: 2});
</code></pre>
<p>When the target is a Set or WeakSet, <code>.include</code> asserts that the given <code>val</code> is a
member of the target. SameValueZero equality algorithm is used.</p>
<pre><code>expect(new Set([1, 2])).to.include(2);
</code></pre>
<p>When the target is a Map, <code>.include</code> asserts that the given <code>val</code> is one of
the values of the target. SameValueZero equality algorithm is used.</p>
<pre><code>expect(new Map([['a', 1], ['b', 2]])).to.include(2);
</code></pre>
<p>Because <code>.include</code> does different things based on the target's type, it's
important to check the target's type before using <code>.include</code>. See the <code>.a</code>
doc for info on testing a target's type.</p>
<pre><code>expect([1, 2, 3]).to.be.an('array').that.includes(2);
</code></pre>
<p>By default, strict (<code>===</code>) equality is used to compare array members and
object properties. Add <code>.deep</code> earlier in the chain to use deep equality
instead (WeakSet targets are not supported). See the <code>deep-eql</code> project
page for info on the deep equality algorithm: https://github.com/chaijs/deep-eql.</p>
<pre><code>// Target array deeply (but not strictly) includes `{a: 1}`
expect([{a: 1}]).to.deep.include({a: 1});
expect([{a: 1}]).to.not.include({a: 1});

// Target object deeply (but not strictly) includes `x: {a: 1}`
expect({x: {a: 1}}).to.deep.include({x: {a: 1}});
expect({x: {a: 1}}).to.not.include({x: {a: 1}});
</code></pre>
<p>By default, all of the target's properties are searched when working with
objects. This includes properties that are inherited and/or non-enumerable.
Add <code>.own</code> earlier in the chain to exclude the target's inherited
properties from the search.</p>
<pre><code>Object.prototype.b = 2;

expect({a: 1}).to.own.include({a: 1});
expect({a: 1}).to.include({b: 2}).but.not.own.include({b: 2});
</code></pre>
<p>Note that a target object is always only searched for <code>val</code>'s own
enumerable properties.</p>
<p><code>.deep</code> and <code>.own</code> can be combined.</p>
<pre><code>expect({a: {b: 2}}).to.deep.own.include({a: {b: 2}});
</code></pre>
<p>Add <code>.nested</code> earlier in the chain to enable dot- and bracket-notation when
referencing nested properties.</p>
<pre><code>expect({a: {b: ['x', 'y']}}).to.nested.include({'a.b[1]': 'y'});
</code></pre>
<p>If <code>.</code> or <code>[]</code> are part of an actual property name, they can be escaped by
adding two backslashes before them.</p>
<pre><code>expect({'.a': {'[b]': 2}}).to.nested.include({'\\.a.\\[b\\]': 2});
</code></pre>
<p><code>.deep</code> and <code>.nested</code> can be combined.</p>
<pre><code>expect({a: {b: [{c: 3}]}}).to.deep.nested.include({'a.b[0]': {c: 3}});
</code></pre>
<p><code>.own</code> and <code>.nested</code> cannot be combined.</p>
<p>Add <code>.not</code> earlier in the chain to negate <code>.include</code>.</p>
<pre><code>expect('foobar').to.not.include('taco');
expect([1, 2, 3]).to.not.include(4);
</code></pre>
<p>However, it's dangerous to negate <code>.include</code> when the target is an object.
The problem is that it creates uncertain expectations by asserting that the
target object doesn't have all of <code>val</code>'s key/value pairs but may or may
not have some of them. It's often best to identify the exact output that's
expected, and then write an assertion that only accepts that exact output.</p>
<p>When the target object isn't even expected to have <code>val</code>'s keys, it's
often best to assert exactly that.</p>
<pre><code>expect({c: 3}).to.not.have.any.keys('a', 'b'); // Recommended
expect({c: 3}).to.not.include({a: 1, b: 2}); // Not recommended
</code></pre>
<p>When the target object is expected to have <code>val</code>'s keys, it's often best to
assert that each of the properties has its expected value, rather than
asserting that each property doesn't have one of many unexpected values.</p>
<pre><code>expect({a: 3, b: 4}).to.include({a: 3, b: 4}); // Recommended
expect({a: 3, b: 4}).to.not.include({a: 1, b: 2}); // Not recommended
</code></pre>
<p><code>.include</code> accepts an optional <code>msg</code> argument which is a custom error
message to show when the assertion fails. The message can also be given as
the second argument to <code>expect</code>.</p>
<pre><code>expect([1, 2, 3]).to.include(4, 'nooo why fail??');
expect([1, 2, 3], 'nooo why fail??').to.include(4);
</code></pre>
<p><code>.include</code> can also be used as a language chain, causing all <code>.members</code> and
<code>.keys</code> assertions that follow in the chain to require the target to be a
superset of the expected set, rather than an identical set. Note that
<code>.members</code> ignores duplicates in the subset when <code>.include</code> is added.</p>
<pre><code>// Target object's keys are a superset of ['a', 'b'] but not identical
expect({a: 1, b: 2, c: 3}).to.include.all.keys('a', 'b');
expect({a: 1, b: 2, c: 3}).to.not.have.all.keys('a', 'b');

// Target array is a superset of [1, 2] but not identical
expect([1, 2, 3]).to.include.members([1, 2]);
expect([1, 2, 3]).to.not.have.members([1, 2]);

// Duplicates in the subset are ignored
expect([1, 2, 3]).to.include.members([1, 2, 2, 2]);
</code></pre>
<p>Note that adding <code>.any</code> earlier in the chain causes the <code>.keys</code> assertion
to ignore <code>.include</code>.</p>
<pre><code>// Both assertions are identical
expect({a: 1}).to.include.any.keys('a', 'b');
expect({a: 1}).to.have.any.keys('a', 'b');
</code></pre>
<p>The aliases <code>.includes</code>, <code>.contain</code>, and <code>.contains</code> can be used
interchangeably with <code>.include</code>.</p></div>
        

        


<dl class="details">

    

    

    

    

    

    

    

    

    

    

    

    
    

    

    

    
        <p class="tag-source">
            <a href="node_modules_chai_chai.js.html" class="button">View Source</a>
            <span>
                <a href="node_modules_chai_chai.js.html">node_modules/chai/chai.js</a>, <a href="node_modules_chai_chai.js.html#line688">line 688</a>
            </span>
        </p>
    
</dl>


        
    
    </div>
    
    

    

    

    

    

    

    

    

    

    
</article>

</section>







<section>

<header>
    
        <h2>BDD</h2>
        
    
</header>

<article>
    <div class="container-overview">
    
        
            <div class="description"><h3>.ok</h3>
<p>Asserts that the target is a truthy value (considered <code>true</code> in boolean context).
However, it's often best to assert that the target is strictly (<code>===</code>) or
deeply equal to its expected value.</p>
<pre><code>expect(1).to.equal(1); // Recommended
expect(1).to.be.ok; // Not recommended

expect(true).to.be.true; // Recommended
expect(true).to.be.ok; // Not recommended
</code></pre>
<p>Add <code>.not</code> earlier in the chain to negate <code>.ok</code>.</p>
<pre><code>expect(0).to.equal(0); // Recommended
expect(0).to.not.be.ok; // Not recommended

expect(false).to.be.false; // Recommended
expect(false).to.not.be.ok; // Not recommended

expect(null).to.be.null; // Recommended
expect(null).to.not.be.ok; // Not recommended

expect(undefined).to.be.undefined; // Recommended
expect(undefined).to.not.be.ok; // Not recommended
</code></pre>
<p>A custom error message can be given as the second argument to <code>expect</code>.</p>
<pre><code>expect(false, 'nooo why fail??').to.be.ok;</code></pre></div>
        

        


<dl class="details">

    

    

    

    

    

    

    

    

    

    

    

    
    

    

    

    
        <p class="tag-source">
            <a href="node_modules_chai_chai.js.html" class="button">View Source</a>
            <span>
                <a href="node_modules_chai_chai.js.html">node_modules/chai/chai.js</a>, <a href="node_modules_chai_chai.js.html#line967">line 967</a>
            </span>
        </p>
    
</dl>


        
    
    </div>
    
    

    

    

    

    

    

    

    

    

    
</article>

</section>







<section>

<header>
    
        <h2>BDD</h2>
        
    
</header>

<article>
    <div class="container-overview">
    
        
            <div class="description"><h3>.true</h3>
<p>Asserts that the target is strictly (<code>===</code>) equal to <code>true</code>.</p>
<pre><code>expect(true).to.be.true;
</code></pre>
<p>Add <code>.not</code> earlier in the chain to negate <code>.true</code>. However, it's often best
to assert that the target is equal to its expected value, rather than not
equal to <code>true</code>.</p>
<pre><code>expect(false).to.be.false; // Recommended
expect(false).to.not.be.true; // Not recommended

expect(1).to.equal(1); // Recommended
expect(1).to.not.be.true; // Not recommended
</code></pre>
<p>A custom error message can be given as the second argument to <code>expect</code>.</p>
<pre><code>expect(false, 'nooo why fail??').to.be.true;</code></pre></div>
        

        


<dl class="details">

    

    

    

    

    

    

    

    

    

    

    

    
    

    

    

    
        <p class="tag-source">
            <a href="node_modules_chai_chai.js.html" class="button">View Source</a>
            <span>
                <a href="node_modules_chai_chai.js.html">node_modules/chai/chai.js</a>, <a href="node_modules_chai_chai.js.html#line1010">line 1010</a>
            </span>
        </p>
    
</dl>


        
    
    </div>
    
    

    

    

    

    

    

    

    

    

    
</article>

</section>







<section>

<header>
    
        <h2>BDD</h2>
        
    
</header>

<article>
    <div class="container-overview">
    
        
            <div class="description"><h3>.false</h3>
<p>Asserts that the target is strictly (<code>===</code>) equal to <code>false</code>.</p>
<pre><code>expect(false).to.be.false;
</code></pre>
<p>Add <code>.not</code> earlier in the chain to negate <code>.false</code>. However, it's often
best to assert that the target is equal to its expected value, rather than
not equal to <code>false</code>.</p>
<pre><code>expect(true).to.be.true; // Recommended
expect(true).to.not.be.false; // Not recommended

expect(1).to.equal(1); // Recommended
expect(1).to.not.be.false; // Not recommended
</code></pre>
<p>A custom error message can be given as the second argument to <code>expect</code>.</p>
<pre><code>expect(true, 'nooo why fail??').to.be.false;</code></pre></div>
        

        


<dl class="details">

    

    

    

    

    

    

    

    

    

    

    

    
    

    

    

    
        <p class="tag-source">
            <a href="node_modules_chai_chai.js.html" class="button">View Source</a>
            <span>
                <a href="node_modules_chai_chai.js.html">node_modules/chai/chai.js</a>, <a href="node_modules_chai_chai.js.html#line1045">line 1045</a>
            </span>
        </p>
    
</dl>


        
    
    </div>
    
    

    

    

    

    

    

    

    

    

    
</article>

</section>







<section>

<header>
    
        <h2>BDD</h2>
        
    
</header>

<article>
    <div class="container-overview">
    
        
            <div class="description"><h3>.null</h3>
<p>Asserts that the target is strictly (<code>===</code>) equal to <code>null</code>.</p>
<pre><code>expect(null).to.be.null;
</code></pre>
<p>Add <code>.not</code> earlier in the chain to negate <code>.null</code>. However, it's often best
to assert that the target is equal to its expected value, rather than not
equal to <code>null</code>.</p>
<pre><code>expect(1).to.equal(1); // Recommended
expect(1).to.not.be.null; // Not recommended
</code></pre>
<p>A custom error message can be given as the second argument to <code>expect</code>.</p>
<pre><code>expect(42, 'nooo why fail??').to.be.null;</code></pre></div>
        

        


<dl class="details">

    

    

    

    

    

    

    

    

    

    

    

    
    

    

    

    
        <p class="tag-source">
            <a href="node_modules_chai_chai.js.html" class="button">View Source</a>
            <span>
                <a href="node_modules_chai_chai.js.html">node_modules/chai/chai.js</a>, <a href="node_modules_chai_chai.js.html#line1080">line 1080</a>
            </span>
        </p>
    
</dl>


        
    
    </div>
    
    

    

    

    

    

    

    

    

    

    
</article>

</section>







<section>

<header>
    
        <h2>BDD</h2>
        
    
</header>

<article>
    <div class="container-overview">
    
        
            <div class="description"><h3>.undefined</h3>
<p>Asserts that the target is strictly (<code>===</code>) equal to <code>undefined</code>.</p>
<pre><code>expect(undefined).to.be.undefined;
</code></pre>
<p>Add <code>.not</code> earlier in the chain to negate <code>.undefined</code>. However, it's often
best to assert that the target is equal to its expected value, rather than
not equal to <code>undefined</code>.</p>
<pre><code>expect(1).to.equal(1); // Recommended
expect(1).to.not.be.undefined; // Not recommended
</code></pre>
<p>A custom error message can be given as the second argument to <code>expect</code>.</p>
<pre><code>expect(42, 'nooo why fail??').to.be.undefined;</code></pre></div>
        

        


<dl class="details">

    

    

    

    

    

    

    

    

    

    

    

    
    

    

    

    
        <p class="tag-source">
            <a href="node_modules_chai_chai.js.html" class="button">View Source</a>
            <span>
                <a href="node_modules_chai_chai.js.html">node_modules/chai/chai.js</a>, <a href="node_modules_chai_chai.js.html#line1111">line 1111</a>
            </span>
        </p>
    
</dl>


        
    
    </div>
    
    

    

    

    

    

    

    

    

    

    
</article>

</section>







<section>

<header>
    
        <h2>BDD</h2>
        
    
</header>

<article>
    <div class="container-overview">
    
        
            <div class="description"><h3>.NaN</h3>
<p>Asserts that the target is exactly <code>NaN</code>.</p>
<pre><code>expect(NaN).to.be.NaN;
</code></pre>
<p>Add <code>.not</code> earlier in the chain to negate <code>.NaN</code>. However, it's often best
to assert that the target is equal to its expected value, rather than not
equal to <code>NaN</code>.</p>
<pre><code>expect('foo').to.equal('foo'); // Recommended
expect('foo').to.not.be.NaN; // Not recommended
</code></pre>
<p>A custom error message can be given as the second argument to <code>expect</code>.</p>
<pre><code>expect(42, 'nooo why fail??').to.be.NaN;</code></pre></div>
        

        


<dl class="details">

    

    

    

    

    

    

    

    

    

    

    

    
    

    

    

    
        <p class="tag-source">
            <a href="node_modules_chai_chai.js.html" class="button">View Source</a>
            <span>
                <a href="node_modules_chai_chai.js.html">node_modules/chai/chai.js</a>, <a href="node_modules_chai_chai.js.html#line1142">line 1142</a>
            </span>
        </p>
    
</dl>


        
    
    </div>
    
    

    

    

    

    

    

    

    

    

    
</article>

</section>







<section>

<header>
    
        <h2>BDD</h2>
        
    
</header>

<article>
    <div class="container-overview">
    
        
            <div class="description"><h3>.exist</h3>
<p>Asserts that the target is not strictly (<code>===</code>) equal to either <code>null</code> or
<code>undefined</code>. However, it's often best to assert that the target is equal to
its expected value.</p>
<pre><code>expect(1).to.equal(1); // Recommended
expect(1).to.exist; // Not recommended

expect(0).to.equal(0); // Recommended
expect(0).to.exist; // Not recommended
</code></pre>
<p>Add <code>.not</code> earlier in the chain to negate <code>.exist</code>.</p>
<pre><code>expect(null).to.be.null; // Recommended
expect(null).to.not.exist; // Not recommended

expect(undefined).to.be.undefined; // Recommended
expect(undefined).to.not.exist; // Not recommended
</code></pre>
<p>A custom error message can be given as the second argument to <code>expect</code>.</p>
<pre><code>expect(null, 'nooo why fail??').to.exist;
</code></pre>
<p>The alias <code>.exists</code> can be used interchangeably with <code>.exist</code>.</p></div>
        

        


<dl class="details">

    

    

    

    

    

    

    

    

    

    

    

    
    

    

    

    
        <p class="tag-source">
            <a href="node_modules_chai_chai.js.html" class="button">View Source</a>
            <span>
                <a href="node_modules_chai_chai.js.html">node_modules/chai/chai.js</a>, <a href="node_modules_chai_chai.js.html#line1173">line 1173</a>
            </span>
        </p>
    
</dl>


        
    
    </div>
    
    

    

    

    

    

    

    

    

    

    
</article>

</section>







<section>

<header>
    
        <h2>BDD</h2>
        
    
</header>

<article>
    <div class="container-overview">
    
        
            <div class="description"><h3>.empty</h3>
<p>When the target is a string or array, <code>.empty</code> asserts that the target's
<code>length</code> property is strictly (<code>===</code>) equal to <code>0</code>.</p>
<pre><code>expect([]).to.be.empty;
expect('').to.be.empty;
</code></pre>
<p>When the target is a map or set, <code>.empty</code> asserts that the target's <code>size</code>
property is strictly equal to <code>0</code>.</p>
<pre><code>expect(new Set()).to.be.empty;
expect(new Map()).to.be.empty;
</code></pre>
<p>When the target is a non-function object, <code>.empty</code> asserts that the target
doesn't have any own enumerable properties. Properties with Symbol-based
keys are excluded from the count.</p>
<pre><code>expect({}).to.be.empty;
</code></pre>
<p>Because <code>.empty</code> does different things based on the target's type, it's
important to check the target's type before using <code>.empty</code>. See the <code>.a</code>
doc for info on testing a target's type.</p>
<pre><code>expect([]).to.be.an('array').that.is.empty;
</code></pre>
<p>Add <code>.not</code> earlier in the chain to negate <code>.empty</code>. However, it's often
best to assert that the target contains its expected number of values,
rather than asserting that it's not empty.</p>
<pre><code>expect([1, 2, 3]).to.have.lengthOf(3); // Recommended
expect([1, 2, 3]).to.not.be.empty; // Not recommended

expect(new Set([1, 2, 3])).to.have.property('size', 3); // Recommended
expect(new Set([1, 2, 3])).to.not.be.empty; // Not recommended

expect(Object.keys({a: 1})).to.have.lengthOf(1); // Recommended
expect({a: 1}).to.not.be.empty; // Not recommended
</code></pre>
<p>A custom error message can be given as the second argument to <code>expect</code>.</p>
<pre><code>expect([1, 2, 3], 'nooo why fail??').to.be.empty;</code></pre></div>
        

        


<dl class="details">

    

    

    

    

    

    

    

    

    

    

    

    
    

    

    

    
        <p class="tag-source">
            <a href="node_modules_chai_chai.js.html" class="button">View Source</a>
            <span>
                <a href="node_modules_chai_chai.js.html">node_modules/chai/chai.js</a>, <a href="node_modules_chai_chai.js.html#line1218">line 1218</a>
            </span>
        </p>
    
</dl>


        
    
    </div>
    
    

    

    

    

    

    

    

    

    

    
</article>

</section>







<section>

<header>
    
        <h2>BDD</h2>
        
    
</header>

<article>
    <div class="container-overview">
    
        
            <div class="description"><h3>.arguments</h3>
<p>Asserts that the target is an <code>arguments</code> object.</p>
<pre><code>function test () {
  expect(arguments).to.be.arguments;
}

test();
</code></pre>
<p>Add <code>.not</code> earlier in the chain to negate <code>.arguments</code>. However, it's often
best to assert which type the target is expected to be, rather than
asserting that its not an <code>arguments</code> object.</p>
<pre><code>expect('foo').to.be.a('string'); // Recommended
expect('foo').to.not.be.arguments; // Not recommended
</code></pre>
<p>A custom error message can be given as the second argument to <code>expect</code>.</p>
<pre><code>expect({}, 'nooo why fail??').to.be.arguments;
</code></pre>
<p>The alias <code>.Arguments</code> can be used interchangeably with <code>.arguments</code>.</p></div>
        

        


<dl class="details">

    

    

    

    

    

    

    

    

    

    

    

    
    

    

    

    
        <p class="tag-source">
            <a href="node_modules_chai_chai.js.html" class="button">View Source</a>
            <span>
                <a href="node_modules_chai_chai.js.html">node_modules/chai/chai.js</a>, <a href="node_modules_chai_chai.js.html#line1312">line 1312</a>
            </span>
        </p>
    
</dl>


        
    
    </div>
    
    

    

    

    

    

    

    

    

    

    
</article>

</section>







<section>

<header>
    
        <h2>BDD</h2>
        
    
</header>

<article>
    <div class="container-overview">
    
        
            <div class="description"><h3>.equal(val[, msg])</h3>
<p>Asserts that the target is strictly (<code>===</code>) equal to the given <code>val</code>.</p>
<pre><code>expect(1).to.equal(1);
expect('foo').to.equal('foo');
</code></pre>
<p>Add <code>.deep</code> earlier in the chain to use deep equality instead. See the
<code>deep-eql</code> project page for info on the deep equality algorithm:
https://github.com/chaijs/deep-eql.</p>
<pre><code>// Target object deeply (but not strictly) equals `{a: 1}`
expect({a: 1}).to.deep.equal({a: 1});
expect({a: 1}).to.not.equal({a: 1});

// Target array deeply (but not strictly) equals `[1, 2]`
expect([1, 2]).to.deep.equal([1, 2]);
expect([1, 2]).to.not.equal([1, 2]);
</code></pre>
<p>Add <code>.not</code> earlier in the chain to negate <code>.equal</code>. However, it's often
best to assert that the target is equal to its expected value, rather than
not equal to one of countless unexpected values.</p>
<pre><code>expect(1).to.equal(1); // Recommended
expect(1).to.not.equal(2); // Not recommended
</code></pre>
<p><code>.equal</code> accepts an optional <code>msg</code> argument which is a custom error message
to show when the assertion fails. The message can also be given as the
second argument to <code>expect</code>.</p>
<pre><code>expect(1).to.equal(2, 'nooo why fail??');
expect(1, 'nooo why fail??').to.equal(2);
</code></pre>
<p>The aliases <code>.equals</code> and <code>eq</code> can be used interchangeably with <code>.equal</code>.</p></div>
        

        


<dl class="details">

    

    

    

    

    

    

    

    

    

    

    

    
    

    

    

    
        <p class="tag-source">
            <a href="node_modules_chai_chai.js.html" class="button">View Source</a>
            <span>
                <a href="node_modules_chai_chai.js.html">node_modules/chai/chai.js</a>, <a href="node_modules_chai_chai.js.html#line1355">line 1355</a>
            </span>
        </p>
    
</dl>


        
    
    </div>
    
    

    

    

    

    

    

    

    

    

    
</article>

</section>







<section>

<header>
    
        <h2>BDD</h2>
        
    
</header>

<article>
    <div class="container-overview">
    
        
            <div class="description"><h3>.eql(obj[, msg])</h3>
<p>Asserts that the target is deeply equal to the given <code>obj</code>. See the
<code>deep-eql</code> project page for info on the deep equality algorithm:
https://github.com/chaijs/deep-eql.</p>
<pre><code>// Target object is deeply (but not strictly) equal to {a: 1}
expect({a: 1}).to.eql({a: 1}).but.not.equal({a: 1});

// Target array is deeply (but not strictly) equal to [1, 2]
expect([1, 2]).to.eql([1, 2]).but.not.equal([1, 2]);
</code></pre>
<p>Add <code>.not</code> earlier in the chain to negate <code>.eql</code>. However, it's often best
to assert that the target is deeply equal to its expected value, rather
than not deeply equal to one of countless unexpected values.</p>
<pre><code>expect({a: 1}).to.eql({a: 1}); // Recommended
expect({a: 1}).to.not.eql({b: 2}); // Not recommended
</code></pre>
<p><code>.eql</code> accepts an optional <code>msg</code> argument which is a custom error message
to show when the assertion fails. The message can also be given as the
second argument to <code>expect</code>.</p>
<pre><code>expect({a: 1}).to.eql({b: 2}, 'nooo why fail??');
expect({a: 1}, 'nooo why fail??').to.eql({b: 2});
</code></pre>
<p>The alias <code>.eqls</code> can be used interchangeably with <code>.eql</code>.</p>
<p>The <code>.deep.equal</code> assertion is almost identical to <code>.eql</code> but with one
difference: <code>.deep.equal</code> causes deep equality comparisons to also be used
for any other assertions that follow in the chain.</p></div>
        

        


<dl class="details">

    

    

    

    

    

    

    

    

    

    

    

    
    

    

    

    
        <p class="tag-source">
            <a href="node_modules_chai_chai.js.html" class="button">View Source</a>
            <span>
                <a href="node_modules_chai_chai.js.html">node_modules/chai/chai.js</a>, <a href="node_modules_chai_chai.js.html#line1424">line 1424</a>
            </span>
        </p>
    
</dl>


        
    
    </div>
    
    

    

    

    

    

    

    

    

    

    
</article>

</section>







<section>

<header>
    
        <h2>BDD</h2>
        
    
</header>

<article>
    <div class="container-overview">
    
        
            <div class="description"><h3>.above(n[, msg])</h3>
<p>Asserts that the target is a number or a date greater than the given number or date <code>n</code> respectively.
However, it's often best to assert that the target is equal to its expected
value.</p>
<pre><code>expect(2).to.equal(2); // Recommended
expect(2).to.be.above(1); // Not recommended
</code></pre>
<p>Add <code>.lengthOf</code> earlier in the chain to assert that the target's <code>length</code>
or <code>size</code> is greater than the given number <code>n</code>.</p>
<pre><code>expect('foo').to.have.lengthOf(3); // Recommended
expect('foo').to.have.lengthOf.above(2); // Not recommended

expect([1, 2, 3]).to.have.lengthOf(3); // Recommended
expect([1, 2, 3]).to.have.lengthOf.above(2); // Not recommended
</code></pre>
<p>Add <code>.not</code> earlier in the chain to negate <code>.above</code>.</p>
<pre><code>expect(2).to.equal(2); // Recommended
expect(1).to.not.be.above(2); // Not recommended
</code></pre>
<p><code>.above</code> accepts an optional <code>msg</code> argument which is a custom error message
to show when the assertion fails. The message can also be given as the
second argument to <code>expect</code>.</p>
<pre><code>expect(1).to.be.above(2, 'nooo why fail??');
expect(1, 'nooo why fail??').to.be.above(2);
</code></pre>
<p>The aliases <code>.gt</code> and <code>.greaterThan</code> can be used interchangeably with
<code>.above</code>.</p></div>
        

        


<dl class="details">

    

    

    

    

    

    

    

    

    

    

    

    
    

    

    

    
        <p class="tag-source">
            <a href="node_modules_chai_chai.js.html" class="button">View Source</a>
            <span>
                <a href="node_modules_chai_chai.js.html">node_modules/chai/chai.js</a>, <a href="node_modules_chai_chai.js.html#line1480">line 1480</a>
            </span>
        </p>
    
</dl>


        
    
    </div>
    
    

    

    

    

    

    

    

    

    

    
</article>

</section>







<section>

<header>
    
        <h2>BDD</h2>
        
    
</header>

<article>
    <div class="container-overview">
    
        
            <div class="description"><h3>.least(n[, msg])</h3>
<p>Asserts that the target is a number or a date greater than or equal to the given
number or date <code>n</code> respectively. However, it's often best to assert that the target is equal to
its expected value.</p>
<pre><code>expect(2).to.equal(2); // Recommended
expect(2).to.be.at.least(1); // Not recommended
expect(2).to.be.at.least(2); // Not recommended
</code></pre>
<p>Add <code>.lengthOf</code> earlier in the chain to assert that the target's <code>length</code>
or <code>size</code> is greater than or equal to the given number <code>n</code>.</p>
<pre><code>expect('foo').to.have.lengthOf(3); // Recommended
expect('foo').to.have.lengthOf.at.least(2); // Not recommended

expect([1, 2, 3]).to.have.lengthOf(3); // Recommended
expect([1, 2, 3]).to.have.lengthOf.at.least(2); // Not recommended
</code></pre>
<p>Add <code>.not</code> earlier in the chain to negate <code>.least</code>.</p>
<pre><code>expect(1).to.equal(1); // Recommended
expect(1).to.not.be.at.least(2); // Not recommended
</code></pre>
<p><code>.least</code> accepts an optional <code>msg</code> argument which is a custom error message
to show when the assertion fails. The message can also be given as the
second argument to <code>expect</code>.</p>
<pre><code>expect(1).to.be.at.least(2, 'nooo why fail??');
expect(1, 'nooo why fail??').to.be.at.least(2);
</code></pre>
<p>The aliases <code>.gte</code> and <code>.greaterThanOrEqual</code> can be used interchangeably with
<code>.least</code>.</p></div>
        

        


<dl class="details">

    

    

    

    

    

    

    

    

    

    

    

    
    

    

    

    
        <p class="tag-source">
            <a href="node_modules_chai_chai.js.html" class="button">View Source</a>
            <span>
                <a href="node_modules_chai_chai.js.html">node_modules/chai/chai.js</a>, <a href="node_modules_chai_chai.js.html#line1584">line 1584</a>
            </span>
        </p>
    
</dl>


        
    
    </div>
    
    

    

    

    

    

    

    

    

    

    
</article>

</section>







<section>

<header>
    
        <h2>BDD</h2>
        
    
</header>

<article>
    <div class="container-overview">
    
        
            <div class="description"><h3>.below(n[, msg])</h3>
<p>Asserts that the target is a number or a date less than the given number or date <code>n</code> respectively.
However, it's often best to assert that the target is equal to its expected
value.</p>
<pre><code>expect(1).to.equal(1); // Recommended
expect(1).to.be.below(2); // Not recommended
</code></pre>
<p>Add <code>.lengthOf</code> earlier in the chain to assert that the target's <code>length</code>
or <code>size</code> is less than the given number <code>n</code>.</p>
<pre><code>expect('foo').to.have.lengthOf(3); // Recommended
expect('foo').to.have.lengthOf.below(4); // Not recommended

expect([1, 2, 3]).to.have.length(3); // Recommended
expect([1, 2, 3]).to.have.lengthOf.below(4); // Not recommended
</code></pre>
<p>Add <code>.not</code> earlier in the chain to negate <code>.below</code>.</p>
<pre><code>expect(2).to.equal(2); // Recommended
expect(2).to.not.be.below(1); // Not recommended
</code></pre>
<p><code>.below</code> accepts an optional <code>msg</code> argument which is a custom error message
to show when the assertion fails. The message can also be given as the
second argument to <code>expect</code>.</p>
<pre><code>expect(2).to.be.below(1, 'nooo why fail??');
expect(2, 'nooo why fail??').to.be.below(1);
</code></pre>
<p>The aliases <code>.lt</code> and <code>.lessThan</code> can be used interchangeably with
<code>.below</code>.</p></div>
        

        


<dl class="details">

    

    

    

    

    

    

    

    

    

    

    

    
    

    

    

    
        <p class="tag-source">
            <a href="node_modules_chai_chai.js.html" class="button">View Source</a>
            <span>
                <a href="node_modules_chai_chai.js.html">node_modules/chai/chai.js</a>, <a href="node_modules_chai_chai.js.html#line1689">line 1689</a>
            </span>
        </p>
    
</dl>


        
    
    </div>
    
    

    

    

    

    

    

    

    

    

    
</article>

</section>







<section>

<header>
    
        <h2>BDD</h2>
        
    
</header>

<article>
    <div class="container-overview">
    
        
            <div class="description"><h3>.most(n[, msg])</h3>
<p>Asserts that the target is a number or a date less than or equal to the given number
or date <code>n</code> respectively. However, it's often best to assert that the target is equal to its
expected value.</p>
<pre><code>expect(1).to.equal(1); // Recommended
expect(1).to.be.at.most(2); // Not recommended
expect(1).to.be.at.most(1); // Not recommended
</code></pre>
<p>Add <code>.lengthOf</code> earlier in the chain to assert that the target's <code>length</code>
or <code>size</code> is less than or equal to the given number <code>n</code>.</p>
<pre><code>expect('foo').to.have.lengthOf(3); // Recommended
expect('foo').to.have.lengthOf.at.most(4); // Not recommended

expect([1, 2, 3]).to.have.lengthOf(3); // Recommended
expect([1, 2, 3]).to.have.lengthOf.at.most(4); // Not recommended
</code></pre>
<p>Add <code>.not</code> earlier in the chain to negate <code>.most</code>.</p>
<pre><code>expect(2).to.equal(2); // Recommended
expect(2).to.not.be.at.most(1); // Not recommended
</code></pre>
<p><code>.most</code> accepts an optional <code>msg</code> argument which is a custom error message
to show when the assertion fails. The message can also be given as the
second argument to <code>expect</code>.</p>
<pre><code>expect(2).to.be.at.most(1, 'nooo why fail??');
expect(2, 'nooo why fail??').to.be.at.most(1);
</code></pre>
<p>The aliases <code>.lte</code> and <code>.lessThanOrEqual</code> can be used interchangeably with
<code>.most</code>.</p></div>
        

        


<dl class="details">

    

    

    

    

    

    

    

    

    

    

    

    
    

    

    

    
        <p class="tag-source">
            <a href="node_modules_chai_chai.js.html" class="button">View Source</a>
            <span>
                <a href="node_modules_chai_chai.js.html">node_modules/chai/chai.js</a>, <a href="node_modules_chai_chai.js.html#line1793">line 1793</a>
            </span>
        </p>
    
</dl>


        
    
    </div>
    
    

    

    

    

    

    

    

    

    

    
</article>

</section>







<section>

<header>
    
        <h2>BDD</h2>
        
    
</header>

<article>
    <div class="container-overview">
    
        
            <div class="description"><h3>.within(start, finish[, msg])</h3>
<p>Asserts that the target is a number or a date greater than or equal to the given
number or date <code>start</code>, and less than or equal to the given number or date <code>finish</code> respectively.
However, it's often best to assert that the target is equal to its expected
value.</p>
<pre><code>expect(2).to.equal(2); // Recommended
expect(2).to.be.within(1, 3); // Not recommended
expect(2).to.be.within(2, 3); // Not recommended
expect(2).to.be.within(1, 2); // Not recommended
</code></pre>
<p>Add <code>.lengthOf</code> earlier in the chain to assert that the target's <code>length</code>
or <code>size</code> is greater than or equal to the given number <code>start</code>, and less
than or equal to the given number <code>finish</code>.</p>
<pre><code>expect('foo').to.have.lengthOf(3); // Recommended
expect('foo').to.have.lengthOf.within(2, 4); // Not recommended

expect([1, 2, 3]).to.have.lengthOf(3); // Recommended
expect([1, 2, 3]).to.have.lengthOf.within(2, 4); // Not recommended
</code></pre>
<p>Add <code>.not</code> earlier in the chain to negate <code>.within</code>.</p>
<pre><code>expect(1).to.equal(1); // Recommended
expect(1).to.not.be.within(2, 4); // Not recommended
</code></pre>
<p><code>.within</code> accepts an optional <code>msg</code> argument which is a custom error
message to show when the assertion fails. The message can also be given as
the second argument to <code>expect</code>.</p>
<pre><code>expect(4).to.be.within(1, 3, 'nooo why fail??');
expect(4, 'nooo why fail??').to.be.within(1, 3);</code></pre></div>
        

        


<dl class="details">

    

    

    

    

    

    

    

    

    

    

    

    
    

    

    

    
        <p class="tag-source">
            <a href="node_modules_chai_chai.js.html" class="button">View Source</a>
            <span>
                <a href="node_modules_chai_chai.js.html">node_modules/chai/chai.js</a>, <a href="node_modules_chai_chai.js.html#line1898">line 1898</a>
            </span>
        </p>
    
</dl>


        
    
    </div>
    
    

    

    

    

    

    

    

    

    

    
</article>

</section>







<section>

<header>
    
        <h2>BDD</h2>
        
    
</header>

<article>
    <div class="container-overview">
    
        
            <div class="description"><h3>.instanceof(constructor[, msg])</h3>
<p>Asserts that the target is an instance of the given <code>constructor</code>.</p>
<pre><code>function Cat () { }

expect(new Cat()).to.be.an.instanceof(Cat);
expect([1, 2]).to.be.an.instanceof(Array);
</code></pre>
<p>Add <code>.not</code> earlier in the chain to negate <code>.instanceof</code>.</p>
<pre><code>expect({a: 1}).to.not.be.an.instanceof(Array);
</code></pre>
<p><code>.instanceof</code> accepts an optional <code>msg</code> argument which is a custom error
message to show when the assertion fails. The message can also be given as
the second argument to <code>expect</code>.</p>
<pre><code>expect(1).to.be.an.instanceof(Array, 'nooo why fail??');
expect(1, 'nooo why fail??').to.be.an.instanceof(Array);
</code></pre>
<p>Due to limitations in ES5, <code>.instanceof</code> may not always work as expected
when using a transpiler such as Babel or TypeScript. In particular, it may
produce unexpected results when subclassing built-in object such as
<code>Array</code>, <code>Error</code>, and <code>Map</code>. See your transpiler's docs for details:</p>
<ul>
<li>(<a href="https://babeljs.io/docs/usage/caveats/#classes">Babel</a>)</li>
<li>(<a href="https://github.com/Microsoft/TypeScript/wiki/Breaking-Changes#extending-built-ins-like-error-array-and-map-may-no-longer-work">TypeScript</a>)</li>
</ul>
<p>The alias <code>.instanceOf</code> can be used interchangeably with <code>.instanceof</code>.</p></div>
        

        


<dl class="details">

    

    

    

    

    

    

    

    

    

    

    

    
    

    

    

    
        <p class="tag-source">
            <a href="node_modules_chai_chai.js.html" class="button">View Source</a>
            <span>
                <a href="node_modules_chai_chai.js.html">node_modules/chai/chai.js</a>, <a href="node_modules_chai_chai.js.html#line1999">line 1999</a>
            </span>
        </p>
    
</dl>


        
    
    </div>
    
    

    

    

    

    

    

    

    

    

    
</article>

</section>







<section>

<header>
    
        <h2>BDD</h2>
        
    
</header>

<article>
    <div class="container-overview">
    
        
            <div class="description"><h3>.property(name[, val[, msg]])</h3>
<p>Asserts that the target has a property with the given key <code>name</code>.</p>
<pre><code>expect({a: 1}).to.have.property('a');
</code></pre>
<p>When <code>val</code> is provided, <code>.property</code> also asserts that the property's value
is equal to the given <code>val</code>.</p>
<pre><code>expect({a: 1}).to.have.property('a', 1);
</code></pre>
<p>By default, strict (<code>===</code>) equality is used. Add <code>.deep</code> earlier in the
chain to use deep equality instead. See the <code>deep-eql</code> project page for
info on the deep equality algorithm: https://github.com/chaijs/deep-eql.</p>
<pre><code>// Target object deeply (but not strictly) has property `x: {a: 1}`
expect({x: {a: 1}}).to.have.deep.property('x', {a: 1});
expect({x: {a: 1}}).to.not.have.property('x', {a: 1});
</code></pre>
<p>The target's enumerable and non-enumerable properties are always included
in the search. By default, both own and inherited properties are included.
Add <code>.own</code> earlier in the chain to exclude inherited properties from the
search.</p>
<pre><code>Object.prototype.b = 2;

expect({a: 1}).to.have.own.property('a');
expect({a: 1}).to.have.own.property('a', 1);
expect({a: 1}).to.have.property('b');
expect({a: 1}).to.not.have.own.property('b');
</code></pre>
<p><code>.deep</code> and <code>.own</code> can be combined.</p>
<pre><code>expect({x: {a: 1}}).to.have.deep.own.property('x', {a: 1});
</code></pre>
<p>Add <code>.nested</code> earlier in the chain to enable dot- and bracket-notation when
referencing nested properties.</p>
<pre><code>expect({a: {b: ['x', 'y']}}).to.have.nested.property('a.b[1]');
expect({a: {b: ['x', 'y']}}).to.have.nested.property('a.b[1]', 'y');
</code></pre>
<p>If <code>.</code> or <code>[]</code> are part of an actual property name, they can be escaped by
adding two backslashes before them.</p>
<pre><code>expect({'.a': {'[b]': 'x'}}).to.have.nested.property('\\.a.\\[b\\]');
</code></pre>
<p><code>.deep</code> and <code>.nested</code> can be combined.</p>
<pre><code>expect({a: {b: [{c: 3}]}})
  .to.have.deep.nested.property('a.b[0]', {c: 3});
</code></pre>
<p><code>.own</code> and <code>.nested</code> cannot be combined.</p>
<p>Add <code>.not</code> earlier in the chain to negate <code>.property</code>.</p>
<pre><code>expect({a: 1}).to.not.have.property('b');
</code></pre>
<p>However, it's dangerous to negate <code>.property</code> when providing <code>val</code>. The
problem is that it creates uncertain expectations by asserting that the
target either doesn't have a property with the given key <code>name</code>, or that it
does have a property with the given key <code>name</code> but its value isn't equal to
the given <code>val</code>. It's often best to identify the exact output that's
expected, and then write an assertion that only accepts that exact output.</p>
<p>When the target isn't expected to have a property with the given key
<code>name</code>, it's often best to assert exactly that.</p>
<pre><code>expect({b: 2}).to.not.have.property('a'); // Recommended
expect({b: 2}).to.not.have.property('a', 1); // Not recommended
</code></pre>
<p>When the target is expected to have a property with the given key <code>name</code>,
it's often best to assert that the property has its expected value, rather
than asserting that it doesn't have one of many unexpected values.</p>
<pre><code>expect({a: 3}).to.have.property('a', 3); // Recommended
expect({a: 3}).to.not.have.property('a', 1); // Not recommended
</code></pre>
<p><code>.property</code> changes the target of any assertions that follow in the chain
to be the value of the property from the original target object.</p>
<pre><code>expect({a: 1}).to.have.property('a').that.is.a('number');
</code></pre>
<p><code>.property</code> accepts an optional <code>msg</code> argument which is a custom error
message to show when the assertion fails. The message can also be given as
the second argument to <code>expect</code>. When not providing <code>val</code>, only use the
second form.</p>
<pre><code>// Recommended
expect({a: 1}).to.have.property('a', 2, 'nooo why fail??');
expect({a: 1}, 'nooo why fail??').to.have.property('a', 2);
expect({a: 1}, 'nooo why fail??').to.have.property('b');

// Not recommended
expect({a: 1}).to.have.property('b', undefined, 'nooo why fail??');
</code></pre>
<p>The above assertion isn't the same thing as not providing <code>val</code>. Instead,
it's asserting that the target object has a <code>b</code> property that's equal to
<code>undefined</code>.</p>
<p>The assertions <code>.ownProperty</code> and <code>.haveOwnProperty</code> can be used
interchangeably with <code>.own.property</code>.</p></div>
        

        


<dl class="details">

    

    

    

    

    

    

    

    

    

    

    

    
    

    

    

    
        <p class="tag-source">
            <a href="node_modules_chai_chai.js.html" class="button">View Source</a>
            <span>
                <a href="node_modules_chai_chai.js.html">node_modules/chai/chai.js</a>, <a href="node_modules_chai_chai.js.html#line2075">line 2075</a>
            </span>
        </p>
    
</dl>


        
    
    </div>
    
    

    

    

    

    

    

    

    

    

    
</article>

</section>







<section>

<header>
    
        <h2>BDD</h2>
        
    
</header>

<article>
    <div class="container-overview">
    
        
            <div class="description"><h3>.ownPropertyDescriptor(name[, descriptor[, msg]])</h3>
<p>Asserts that the target has its own property descriptor with the given key
<code>name</code>. Enumerable and non-enumerable properties are included in the
search.</p>
<pre><code>expect({a: 1}).to.have.ownPropertyDescriptor('a');
</code></pre>
<p>When <code>descriptor</code> is provided, <code>.ownPropertyDescriptor</code> also asserts that
the property's descriptor is deeply equal to the given <code>descriptor</code>. See
the <code>deep-eql</code> project page for info on the deep equality algorithm:
https://github.com/chaijs/deep-eql.</p>
<pre><code>expect({a: 1}).to.have.ownPropertyDescriptor('a', {
  configurable: true,
  enumerable: true,
  writable: true,
  value: 1,
});
</code></pre>
<p>Add <code>.not</code> earlier in the chain to negate <code>.ownPropertyDescriptor</code>.</p>
<pre><code>expect({a: 1}).to.not.have.ownPropertyDescriptor('b');
</code></pre>
<p>However, it's dangerous to negate <code>.ownPropertyDescriptor</code> when providing
a <code>descriptor</code>. The problem is that it creates uncertain expectations by
asserting that the target either doesn't have a property descriptor with
the given key <code>name</code>, or that it does have a property descriptor with the
given key <code>name</code> but its not deeply equal to the given <code>descriptor</code>. It's
often best to identify the exact output that's expected, and then write an
assertion that only accepts that exact output.</p>
<p>When the target isn't expected to have a property descriptor with the given
key <code>name</code>, it's often best to assert exactly that.</p>
<pre><code>// Recommended
expect({b: 2}).to.not.have.ownPropertyDescriptor('a');

// Not recommended
expect({b: 2}).to.not.have.ownPropertyDescriptor('a', {
  configurable: true,
  enumerable: true,
  writable: true,
  value: 1,
});
</code></pre>
<p>When the target is expected to have a property descriptor with the given
key <code>name</code>, it's often best to assert that the property has its expected
descriptor, rather than asserting that it doesn't have one of many
unexpected descriptors.</p>
<pre><code>// Recommended
expect({a: 3}).to.have.ownPropertyDescriptor('a', {
  configurable: true,
  enumerable: true,
  writable: true,
  value: 3,
});

// Not recommended
expect({a: 3}).to.not.have.ownPropertyDescriptor('a', {
  configurable: true,
  enumerable: true,
  writable: true,
  value: 1,
});
</code></pre>
<p><code>.ownPropertyDescriptor</code> changes the target of any assertions that follow
in the chain to be the value of the property descriptor from the original
target object.</p>
<pre><code>expect({a: 1}).to.have.ownPropertyDescriptor('a')
  .that.has.property('enumerable', true);
</code></pre>
<p><code>.ownPropertyDescriptor</code> accepts an optional <code>msg</code> argument which is a
custom error message to show when the assertion fails. The message can also
be given as the second argument to <code>expect</code>. When not providing
<code>descriptor</code>, only use the second form.</p>
<pre><code>// Recommended
expect({a: 1}).to.have.ownPropertyDescriptor('a', {
  configurable: true,
  enumerable: true,
  writable: true,
  value: 2,
}, 'nooo why fail??');

// Recommended
expect({a: 1}, 'nooo why fail??').to.have.ownPropertyDescriptor('a', {
  configurable: true,
  enumerable: true,
  writable: true,
  value: 2,
});

// Recommended
expect({a: 1}, 'nooo why fail??').to.have.ownPropertyDescriptor('b');

// Not recommended
expect({a: 1})
  .to.have.ownPropertyDescriptor('b', undefined, 'nooo why fail??');
</code></pre>
<p>The above assertion isn't the same thing as not providing <code>descriptor</code>.
Instead, it's asserting that the target object has a <code>b</code> property
descriptor that's deeply equal to <code>undefined</code>.</p>
<p>The alias <code>.haveOwnPropertyDescriptor</code> can be used interchangeably with
<code>.ownPropertyDescriptor</code>.</p></div>
        

        


<dl class="details">

    

    

    

    

    

    

    

    

    

    

    

    
    

    

    

    
        <p class="tag-source">
            <a href="node_modules_chai_chai.js.html" class="button">View Source</a>
            <span>
                <a href="node_modules_chai_chai.js.html">node_modules/chai/chai.js</a>, <a href="node_modules_chai_chai.js.html#line2284">line 2284</a>
            </span>
        </p>
    
</dl>


        
    
    </div>
    
    

    

    

    

    

    

    

    

    

    
</article>

</section>







<section>

<header>
    
        <h2>BDD</h2>
        
    
</header>

<article>
    <div class="container-overview">
    
        
            <div class="description"><h3>.lengthOf(n[, msg])</h3>
<p>Asserts that the target's <code>length</code> or <code>size</code> is equal to the given number
<code>n</code>.</p>
<pre><code>expect([1, 2, 3]).to.have.lengthOf(3);
expect('foo').to.have.lengthOf(3);
expect(new Set([1, 2, 3])).to.have.lengthOf(3);
expect(new Map([['a', 1], ['b', 2], ['c', 3]])).to.have.lengthOf(3);
</code></pre>
<p>Add <code>.not</code> earlier in the chain to negate <code>.lengthOf</code>. However, it's often
best to assert that the target's <code>length</code> property is equal to its expected
value, rather than not equal to one of many unexpected values.</p>
<pre><code>expect('foo').to.have.lengthOf(3); // Recommended
expect('foo').to.not.have.lengthOf(4); // Not recommended
</code></pre>
<p><code>.lengthOf</code> accepts an optional <code>msg</code> argument which is a custom error
message to show when the assertion fails. The message can also be given as
the second argument to <code>expect</code>.</p>
<pre><code>expect([1, 2, 3]).to.have.lengthOf(2, 'nooo why fail??');
expect([1, 2, 3], 'nooo why fail??').to.have.lengthOf(2);
</code></pre>
<p><code>.lengthOf</code> can also be used as a language chain, causing all <code>.above</code>,
<code>.below</code>, <code>.least</code>, <code>.most</code>, and <code>.within</code> assertions that follow in the
chain to use the target's <code>length</code> property as the target. However, it's
often best to assert that the target's <code>length</code> property is equal to its
expected length, rather than asserting that its <code>length</code> property falls
within some range of values.</p>
<pre><code>// Recommended
expect([1, 2, 3]).to.have.lengthOf(3);

// Not recommended
expect([1, 2, 3]).to.have.lengthOf.above(2);
expect([1, 2, 3]).to.have.lengthOf.below(4);
expect([1, 2, 3]).to.have.lengthOf.at.least(3);
expect([1, 2, 3]).to.have.lengthOf.at.most(3);
expect([1, 2, 3]).to.have.lengthOf.within(2,4);
</code></pre>
<p>Due to a compatibility issue, the alias <code>.length</code> can't be chained directly
off of an uninvoked method such as <code>.a</code>. Therefore, <code>.length</code> can't be used
interchangeably with <code>.lengthOf</code> in every situation. It's recommended to
always use <code>.lengthOf</code> instead of <code>.length</code>.</p>
<pre><code>expect([1, 2, 3]).to.have.a.length(3); // incompatible; throws error
expect([1, 2, 3]).to.have.a.lengthOf(3);  // passes as expected</code></pre></div>
        

        


<dl class="details">

    

    

    

    

    

    

    

    

    

    

    

    
    

    

    

    
        <p class="tag-source">
            <a href="node_modules_chai_chai.js.html" class="button">View Source</a>
            <span>
                <a href="node_modules_chai_chai.js.html">node_modules/chai/chai.js</a>, <a href="node_modules_chai_chai.js.html#line2433">line 2433</a>
            </span>
        </p>
    
</dl>


        
    
    </div>
    
    

    

    

    

    

    

    

    

    

    
</article>

</section>







<section>

<header>
    
        <h2>BDD</h2>
        
    
</header>

<article>
    <div class="container-overview">
    
        
            <div class="description"><h3>.match(re[, msg])</h3>
<p>Asserts that the target matches the given regular expression <code>re</code>.</p>
<pre><code>expect('foobar').to.match(/^foo/);
</code></pre>
<p>Add <code>.not</code> earlier in the chain to negate <code>.match</code>.</p>
<pre><code>expect('foobar').to.not.match(/taco/);
</code></pre>
<p><code>.match</code> accepts an optional <code>msg</code> argument which is a custom error message
to show when the assertion fails. The message can also be given as the
second argument to <code>expect</code>.</p>
<pre><code>expect('foobar').to.match(/taco/, 'nooo why fail??');
expect('foobar', 'nooo why fail??').to.match(/taco/);
</code></pre>
<p>The alias <code>.matches</code> can be used interchangeably with <code>.match</code>.</p></div>
        

        


<dl class="details">

    

    

    

    

    

    

    

    

    

    

    

    
    

    

    

    
        <p class="tag-source">
            <a href="node_modules_chai_chai.js.html" class="button">View Source</a>
            <span>
                <a href="node_modules_chai_chai.js.html">node_modules/chai/chai.js</a>, <a href="node_modules_chai_chai.js.html#line2527">line 2527</a>
            </span>
        </p>
    
</dl>


        
    
    </div>
    
    

    

    

    

    

    

    

    

    

    
</article>

</section>







<section>

<header>
    
        <h2>BDD</h2>
        
    
</header>

<article>
    <div class="container-overview">
    
        
            <div class="description"><h3>.string(str[, msg])</h3>
<p>Asserts that the target string contains the given substring <code>str</code>.</p>
<pre><code>expect('foobar').to.have.string('bar');
</code></pre>
<p>Add <code>.not</code> earlier in the chain to negate <code>.string</code>.</p>
<pre><code>expect('foobar').to.not.have.string('taco');
</code></pre>
<p><code>.string</code> accepts an optional <code>msg</code> argument which is a custom error
message to show when the assertion fails. The message can also be given as
the second argument to <code>expect</code>.</p>
<pre><code>expect('foobar').to.have.string('taco', 'nooo why fail??');
expect('foobar', 'nooo why fail??').to.have.string('taco');</code></pre></div>
        

        


<dl class="details">

    

    

    

    

    

    

    

    

    

    

    

    
    

    

    

    
        <p class="tag-source">
            <a href="node_modules_chai_chai.js.html" class="button">View Source</a>
            <span>
                <a href="node_modules_chai_chai.js.html">node_modules/chai/chai.js</a>, <a href="node_modules_chai_chai.js.html#line2567">line 2567</a>
            </span>
        </p>
    
</dl>


        
    
    </div>
    
    

    

    

    

    

    

    

    

    

    
</article>

</section>







<section>

<header>
    
        <h2>BDD</h2>
        
    
</header>

<article>
    <div class="container-overview">
    
        
            <div class="description"><h3>.keys(key1[, key2[, ...]])</h3>
<p>Asserts that the target object, array, map, or set has the given keys. Only
the target's own inherited properties are included in the search.</p>
<p>When the target is an object or array, keys can be provided as one or more
string arguments, a single array argument, or a single object argument. In
the latter case, only the keys in the given object matter; the values are
ignored.</p>
<pre><code>expect({a: 1, b: 2}).to.have.all.keys('a', 'b');
expect(['x', 'y']).to.have.all.keys(0, 1);

expect({a: 1, b: 2}).to.have.all.keys(['a', 'b']);
expect(['x', 'y']).to.have.all.keys([0, 1]);

expect({a: 1, b: 2}).to.have.all.keys({a: 4, b: 5}); // ignore 4 and 5
expect(['x', 'y']).to.have.all.keys({0: 4, 1: 5}); // ignore 4 and 5
</code></pre>
<p>When the target is a map or set, each key must be provided as a separate
argument.</p>
<pre><code>expect(new Map([['a', 1], ['b', 2]])).to.have.all.keys('a', 'b');
expect(new Set(['a', 'b'])).to.have.all.keys('a', 'b');
</code></pre>
<p>Because <code>.keys</code> does different things based on the target's type, it's
important to check the target's type before using <code>.keys</code>. See the <code>.a</code> doc
for info on testing a target's type.</p>
<pre><code>expect({a: 1, b: 2}).to.be.an('object').that.has.all.keys('a', 'b');
</code></pre>
<p>By default, strict (<code>===</code>) equality is used to compare keys of maps and
sets. Add <code>.deep</code> earlier in the chain to use deep equality instead. See
the <code>deep-eql</code> project page for info on the deep equality algorithm:
https://github.com/chaijs/deep-eql.</p>
<pre><code>// Target set deeply (but not strictly) has key `{a: 1}`
expect(new Set([{a: 1}])).to.have.all.deep.keys([{a: 1}]);
expect(new Set([{a: 1}])).to.not.have.all.keys([{a: 1}]);
</code></pre>
<p>By default, the target must have all of the given keys and no more. Add
<code>.any</code> earlier in the chain to only require that the target have at least
one of the given keys. Also, add <code>.not</code> earlier in the chain to negate
<code>.keys</code>. It's often best to add <code>.any</code> when negating <code>.keys</code>, and to use
<code>.all</code> when asserting <code>.keys</code> without negation.</p>
<p>When negating <code>.keys</code>, <code>.any</code> is preferred because <code>.not.any.keys</code> asserts
exactly what's expected of the output, whereas <code>.not.all.keys</code> creates
uncertain expectations.</p>
<pre><code>// Recommended; asserts that target doesn't have any of the given keys
expect({a: 1, b: 2}).to.not.have.any.keys('c', 'd');

// Not recommended; asserts that target doesn't have all of the given
// keys but may or may not have some of them
expect({a: 1, b: 2}).to.not.have.all.keys('c', 'd');
</code></pre>
<p>When asserting <code>.keys</code> without negation, <code>.all</code> is preferred because
<code>.all.keys</code> asserts exactly what's expected of the output, whereas
<code>.any.keys</code> creates uncertain expectations.</p>
<pre><code>// Recommended; asserts that target has all the given keys
expect({a: 1, b: 2}).to.have.all.keys('a', 'b');

// Not recommended; asserts that target has at least one of the given
// keys but may or may not have more of them
expect({a: 1, b: 2}).to.have.any.keys('a', 'b');
</code></pre>
<p>Note that <code>.all</code> is used by default when neither <code>.all</code> nor <code>.any</code> appear
earlier in the chain. However, it's often best to add <code>.all</code> anyway because
it improves readability.</p>
<pre><code>// Both assertions are identical
expect({a: 1, b: 2}).to.have.all.keys('a', 'b'); // Recommended
expect({a: 1, b: 2}).to.have.keys('a', 'b'); // Not recommended
</code></pre>
<p>Add <code>.include</code> earlier in the chain to require that the target's keys be a
superset of the expected keys, rather than identical sets.</p>
<pre><code>// Target object's keys are a superset of ['a', 'b'] but not identical
expect({a: 1, b: 2, c: 3}).to.include.all.keys('a', 'b');
expect({a: 1, b: 2, c: 3}).to.not.have.all.keys('a', 'b');
</code></pre>
<p>However, if <code>.any</code> and <code>.include</code> are combined, only the <code>.any</code> takes
effect. The <code>.include</code> is ignored in this case.</p>
<pre><code>// Both assertions are identical
expect({a: 1}).to.have.any.keys('a', 'b');
expect({a: 1}).to.include.any.keys('a', 'b');
</code></pre>
<p>A custom error message can be given as the second argument to <code>expect</code>.</p>
<pre><code>expect({a: 1}, 'nooo why fail??').to.have.key('b');
</code></pre>
<p>The alias <code>.key</code> can be used interchangeably with <code>.keys</code>.</p></div>
        

        


<dl class="details">

    

    

    

    

    

    

    

    

    

    

    

    
    

    

    

    
        <p class="tag-source">
            <a href="node_modules_chai_chai.js.html" class="button">View Source</a>
            <span>
                <a href="node_modules_chai_chai.js.html">node_modules/chai/chai.js</a>, <a href="node_modules_chai_chai.js.html#line2606">line 2606</a>
            </span>
        </p>
    
</dl>


        
    
    </div>
    
    

    

    

    

    

    

    

    

    

    
</article>

</section>







<section>

<header>
    
        <h2>BDD</h2>
        
    
</header>

<article>
    <div class="container-overview">
    
        
            <div class="description"><h3>.throw([errorLike], [errMsgMatcher], [msg])</h3>
<p>When no arguments are provided, <code>.throw</code> invokes the target function and
asserts that an error is thrown.</p>
<pre><code>var badFn = function () { throw new TypeError('Illegal salmon!'); };

expect(badFn).to.throw();
</code></pre>
<p>When one argument is provided, and it's an error constructor, <code>.throw</code>
invokes the target function and asserts that an error is thrown that's an
instance of that error constructor.</p>
<pre><code>var badFn = function () { throw new TypeError('Illegal salmon!'); };

expect(badFn).to.throw(TypeError);
</code></pre>
<p>When one argument is provided, and it's an error instance, <code>.throw</code> invokes
the target function and asserts that an error is thrown that's strictly
(<code>===</code>) equal to that error instance.</p>
<pre><code>var err = new TypeError('Illegal salmon!');
var badFn = function () { throw err; };

expect(badFn).to.throw(err);
</code></pre>
<p>When one argument is provided, and it's a string, <code>.throw</code> invokes the
target function and asserts that an error is thrown with a message that
contains that string.</p>
<pre><code>var badFn = function () { throw new TypeError('Illegal salmon!'); };

expect(badFn).to.throw('salmon');
</code></pre>
<p>When one argument is provided, and it's a regular expression, <code>.throw</code>
invokes the target function and asserts that an error is thrown with a
message that matches that regular expression.</p>
<pre><code>var badFn = function () { throw new TypeError('Illegal salmon!'); };

expect(badFn).to.throw(/salmon/);
</code></pre>
<p>When two arguments are provided, and the first is an error instance or
constructor, and the second is a string or regular expression, <code>.throw</code>
invokes the function and asserts that an error is thrown that fulfills both
conditions as described above.</p>
<pre><code>var err = new TypeError('Illegal salmon!');
var badFn = function () { throw err; };

expect(badFn).to.throw(TypeError, 'salmon');
expect(badFn).to.throw(TypeError, /salmon/);
expect(badFn).to.throw(err, 'salmon');
expect(badFn).to.throw(err, /salmon/);
</code></pre>
<p>Add <code>.not</code> earlier in the chain to negate <code>.throw</code>.</p>
<pre><code>var goodFn = function () {};

expect(goodFn).to.not.throw();
</code></pre>
<p>However, it's dangerous to negate <code>.throw</code> when providing any arguments.
The problem is that it creates uncertain expectations by asserting that the
target either doesn't throw an error, or that it throws an error but of a
different type than the given type, or that it throws an error of the given
type but with a message that doesn't include the given string. It's often
best to identify the exact output that's expected, and then write an
assertion that only accepts that exact output.</p>
<p>When the target isn't expected to throw an error, it's often best to assert
exactly that.</p>
<pre><code>var goodFn = function () {};

expect(goodFn).to.not.throw(); // Recommended
expect(goodFn).to.not.throw(ReferenceError, 'x'); // Not recommended
</code></pre>
<p>When the target is expected to throw an error, it's often best to assert
that the error is of its expected type, and has a message that includes an
expected string, rather than asserting that it doesn't have one of many
unexpected types, and doesn't have a message that includes some string.</p>
<pre><code>var badFn = function () { throw new TypeError('Illegal salmon!'); };

expect(badFn).to.throw(TypeError, 'salmon'); // Recommended
expect(badFn).to.not.throw(ReferenceError, 'x'); // Not recommended
</code></pre>
<p><code>.throw</code> changes the target of any assertions that follow in the chain to
be the error object that's thrown.</p>
<pre><code>var err = new TypeError('Illegal salmon!');
err.code = 42;
var badFn = function () { throw err; };

expect(badFn).to.throw(TypeError).with.property('code', 42);
</code></pre>
<p><code>.throw</code> accepts an optional <code>msg</code> argument which is a custom error message
to show when the assertion fails. The message can also be given as the
second argument to <code>expect</code>. When not providing two arguments, always use
the second form.</p>
<pre><code>var goodFn = function () {};

expect(goodFn).to.throw(TypeError, 'x', 'nooo why fail??');
expect(goodFn, 'nooo why fail??').to.throw();
</code></pre>
<p>Due to limitations in ES5, <code>.throw</code> may not always work as expected when
using a transpiler such as Babel or TypeScript. In particular, it may
produce unexpected results when subclassing the built-in <code>Error</code> object and
then passing the subclassed constructor to <code>.throw</code>. See your transpiler's
docs for details:</p>
<ul>
<li>(<a href="https://babeljs.io/docs/usage/caveats/#classes">Babel</a>)</li>
<li>(<a href="https://github.com/Microsoft/TypeScript/wiki/Breaking-Changes#extending-built-ins-like-error-array-and-map-may-no-longer-work">TypeScript</a>)</li>
</ul>
<p>Beware of some common mistakes when using the <code>throw</code> assertion. One common
mistake is to accidentally invoke the function yourself instead of letting
the <code>throw</code> assertion invoke the function for you. For example, when
testing if a function named <code>fn</code> throws, provide <code>fn</code> instead of <code>fn()</code> as
the target for the assertion.</p>
<pre><code>expect(fn).to.throw();     // Good! Tests `fn` as desired
expect(fn()).to.throw();   // Bad! Tests result of `fn()`, not `fn`
</code></pre>
<p>If you need to assert that your function <code>fn</code> throws when passed certain
arguments, then wrap a call to <code>fn</code> inside of another function.</p>
<pre><code>expect(function () { fn(42); }).to.throw();  // Function expression
expect(() =&gt; fn(42)).to.throw();             // ES6 arrow function
</code></pre>
<p>Another common mistake is to provide an object method (or any stand-alone
function that relies on <code>this</code>) as the target of the assertion. Doing so is
problematic because the <code>this</code> context will be lost when the function is
invoked by <code>.throw</code>; there's no way for it to know what <code>this</code> is supposed
to be. There are two ways around this problem. One solution is to wrap the
method or function call inside of another function. Another solution is to
use <code>bind</code>.</p>
<pre><code>expect(function () { cat.meow(); }).to.throw();  // Function expression
expect(() =&gt; cat.meow()).to.throw();             // ES6 arrow function
expect(cat.meow.bind(cat)).to.throw();           // Bind
</code></pre>
<p>Finally, it's worth mentioning that it's a best practice in JavaScript to
only throw <code>Error</code> and derivatives of <code>Error</code> such as <code>ReferenceError</code>,
<code>TypeError</code>, and user-defined objects that extend <code>Error</code>. No other type of
value will generate a stack trace when initialized. With that said, the
<code>throw</code> assertion does technically support any type of value being thrown,
not just <code>Error</code> and its derivatives.</p>
<p>The aliases <code>.throws</code> and <code>.Throw</code> can be used interchangeably with
<code>.throw</code>.</p></div>
        

        


<dl class="details">

    

    

    

    

    

    

    

    

    

    

    

    
    

    
    <dt class="tag-see">See:</dt>
    <dd class="tag-see">
        <ul>
            <li><a href="https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Error#Error_types">https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Error#Error_types</a></li>
        </ul>
    </dd>
    

    

    
        <p class="tag-source">
            <a href="node_modules_chai_chai.js.html" class="button">View Source</a>
            <span>
                <a href="node_modules_chai_chai.js.html">node_modules/chai/chai.js</a>, <a href="node_modules_chai_chai.js.html#line2839">line 2839</a>
            </span>
        </p>
    
</dl>


        
    
    </div>
    
    

    

    

    

    

    

    

    

    

    
</article>

</section>







<section>

<header>
    
        <h2>BDD</h2>
        
    
</header>

<article>
    <div class="container-overview">
    
        
            <div class="description"><h3>.respondTo(method[, msg])</h3>
<p>When the target is a non-function object, <code>.respondTo</code> asserts that the
target has a method with the given name <code>method</code>. The method can be own or
inherited, and it can be enumerable or non-enumerable.</p>
<pre><code>function Cat () {}
Cat.prototype.meow = function () {};

expect(new Cat()).to.respondTo('meow');
</code></pre>
<p>When the target is a function, <code>.respondTo</code> asserts that the target's
<code>prototype</code> property has a method with the given name <code>method</code>. Again, the
method can be own or inherited, and it can be enumerable or non-enumerable.</p>
<pre><code>function Cat () {}
Cat.prototype.meow = function () {};

expect(Cat).to.respondTo('meow');
</code></pre>
<p>Add <code>.itself</code> earlier in the chain to force <code>.respondTo</code> to treat the
target as a non-function object, even if it's a function. Thus, it asserts
that the target has a method with the given name <code>method</code>, rather than
asserting that the target's <code>prototype</code> property has a method with the
given name <code>method</code>.</p>
<pre><code>function Cat () {}
Cat.prototype.meow = function () {};
Cat.hiss = function () {};

expect(Cat).itself.to.respondTo('hiss').but.not.respondTo('meow');
</code></pre>
<p>When not adding <code>.itself</code>, it's important to check the target's type before
using <code>.respondTo</code>. See the <code>.a</code> doc for info on checking a target's type.</p>
<pre><code>function Cat () {}
Cat.prototype.meow = function () {};

expect(new Cat()).to.be.an('object').that.respondsTo('meow');
</code></pre>
<p>Add <code>.not</code> earlier in the chain to negate <code>.respondTo</code>.</p>
<pre><code>function Dog () {}
Dog.prototype.bark = function () {};

expect(new Dog()).to.not.respondTo('meow');
</code></pre>
<p><code>.respondTo</code> accepts an optional <code>msg</code> argument which is a custom error
message to show when the assertion fails. The message can also be given as
the second argument to <code>expect</code>.</p>
<pre><code>expect({}).to.respondTo('meow', 'nooo why fail??');
expect({}, 'nooo why fail??').to.respondTo('meow');
</code></pre>
<p>The alias <code>.respondsTo</code> can be used interchangeably with <code>.respondTo</code>.</p></div>
        

        


<dl class="details">

    

    

    

    

    

    

    

    

    

    

    

    
    

    

    

    
        <p class="tag-source">
            <a href="node_modules_chai_chai.js.html" class="button">View Source</a>
            <span>
                <a href="node_modules_chai_chai.js.html">node_modules/chai/chai.js</a>, <a href="node_modules_chai_chai.js.html#line3134">line 3134</a>
            </span>
        </p>
    
</dl>


        
    
    </div>
    
    

    

    

    

    

    

    

    

    

    
</article>

</section>







<section>

<header>
    
        <h2>BDD</h2>
        
    
</header>

<article>
    <div class="container-overview">
    
        
            <div class="description"><h3>.itself</h3>
<p>Forces all <code>.respondTo</code> assertions that follow in the chain to behave as if
the target is a non-function object, even if it's a function. Thus, it
causes <code>.respondTo</code> to assert that the target has a method with the given
name, rather than asserting that the target's <code>prototype</code> property has a
method with the given name.</p>
<pre><code>function Cat () {}
Cat.prototype.meow = function () {};
Cat.hiss = function () {};

expect(Cat).itself.to.respondTo('hiss').but.not.respondTo('meow');</code></pre></div>
        

        


<dl class="details">

    

    

    

    

    

    

    

    

    

    

    

    
    

    

    

    
        <p class="tag-source">
            <a href="node_modules_chai_chai.js.html" class="button">View Source</a>
            <span>
                <a href="node_modules_chai_chai.js.html">node_modules/chai/chai.js</a>, <a href="node_modules_chai_chai.js.html#line3217">line 3217</a>
            </span>
        </p>
    
</dl>


        
    
    </div>
    
    

    

    

    

    

    

    

    

    

    
</article>

</section>







<section>

<header>
    
        <h2>BDD</h2>
        
    
</header>

<article>
    <div class="container-overview">
    
        
            <div class="description"><h3>.satisfy(matcher[, msg])</h3>
<p>Invokes the given <code>matcher</code> function with the target being passed as the
first argument, and asserts that the value returned is truthy.</p>
<pre><code>expect(1).to.satisfy(function(num) {
  return num &gt; 0;
});
</code></pre>
<p>Add <code>.not</code> earlier in the chain to negate <code>.satisfy</code>.</p>
<pre><code>expect(1).to.not.satisfy(function(num) {
  return num &gt; 2;
});
</code></pre>
<p><code>.satisfy</code> accepts an optional <code>msg</code> argument which is a custom error
message to show when the assertion fails. The message can also be given as
the second argument to <code>expect</code>.</p>
<pre><code>expect(1).to.satisfy(function(num) {
  return num &gt; 2;
}, 'nooo why fail??');

expect(1, 'nooo why fail??').to.satisfy(function(num) {
  return num &gt; 2;
});
</code></pre>
<p>The alias <code>.satisfies</code> can be used interchangeably with <code>.satisfy</code>.</p></div>
        

        


<dl class="details">

    

    

    

    

    

    

    

    

    

    

    

    
    

    

    

    
        <p class="tag-source">
            <a href="node_modules_chai_chai.js.html" class="button">View Source</a>
            <span>
                <a href="node_modules_chai_chai.js.html">node_modules/chai/chai.js</a>, <a href="node_modules_chai_chai.js.html#line3241">line 3241</a>
            </span>
        </p>
    
</dl>


        
    
    </div>
    
    

    

    

    

    

    

    

    

    

    
</article>

</section>







<section>

<header>
    
        <h2>BDD</h2>
        
    
</header>

<article>
    <div class="container-overview">
    
        
            <div class="description"><h3>.closeTo(expected, delta[, msg])</h3>
<p>Asserts that the target is a number that's within a given +/- <code>delta</code> range
of the given number <code>expected</code>. However, it's often best to assert that the
target is equal to its expected value.</p>
<pre><code>// Recommended
expect(1.5).to.equal(1.5);

// Not recommended
expect(1.5).to.be.closeTo(1, 0.5);
expect(1.5).to.be.closeTo(2, 0.5);
expect(1.5).to.be.closeTo(1, 1);
</code></pre>
<p>Add <code>.not</code> earlier in the chain to negate <code>.closeTo</code>.</p>
<pre><code>expect(1.5).to.equal(1.5); // Recommended
expect(1.5).to.not.be.closeTo(3, 1); // Not recommended
</code></pre>
<p><code>.closeTo</code> accepts an optional <code>msg</code> argument which is a custom error
message to show when the assertion fails. The message can also be given as
the second argument to <code>expect</code>.</p>
<pre><code>expect(1.5).to.be.closeTo(3, 1, 'nooo why fail??');
expect(1.5, 'nooo why fail??').to.be.closeTo(3, 1);
</code></pre>
<p>The alias <code>.approximately</code> can be used interchangeably with <code>.closeTo</code>.</p></div>
        

        


<dl class="details">

    

    

    

    

    

    

    

    

    

    

    

    
    

    

    

    
        <p class="tag-source">
            <a href="node_modules_chai_chai.js.html" class="button">View Source</a>
            <span>
                <a href="node_modules_chai_chai.js.html">node_modules/chai/chai.js</a>, <a href="node_modules_chai_chai.js.html#line3295">line 3295</a>
            </span>
        </p>
    
</dl>


        
    
    </div>
    
    

    

    

    

    

    

    

    

    

    
</article>

</section>







<section>

<header>
    
        <h2>BDD</h2>
        
    
</header>

<article>
    <div class="container-overview">
    
        
            <div class="description"><h3>.members(set[, msg])</h3>
<p>Asserts that the target array has the same members as the given array
<code>set</code>.</p>
<pre><code>expect([1, 2, 3]).to.have.members([2, 1, 3]);
expect([1, 2, 2]).to.have.members([2, 1, 2]);
</code></pre>
<p>By default, members are compared using strict (<code>===</code>) equality. Add <code>.deep</code>
earlier in the chain to use deep equality instead. See the <code>deep-eql</code>
project page for info on the deep equality algorithm:
https://github.com/chaijs/deep-eql.</p>
<pre><code>// Target array deeply (but not strictly) has member `{a: 1}`
expect([{a: 1}]).to.have.deep.members([{a: 1}]);
expect([{a: 1}]).to.not.have.members([{a: 1}]);
</code></pre>
<p>By default, order doesn't matter. Add <code>.ordered</code> earlier in the chain to
require that members appear in the same order.</p>
<pre><code>expect([1, 2, 3]).to.have.ordered.members([1, 2, 3]);
expect([1, 2, 3]).to.have.members([2, 1, 3])
  .but.not.ordered.members([2, 1, 3]);
</code></pre>
<p>By default, both arrays must be the same size. Add <code>.include</code> earlier in
the chain to require that the target's members be a superset of the
expected members. Note that duplicates are ignored in the subset when
<code>.include</code> is added.</p>
<pre><code>// Target array is a superset of [1, 2] but not identical
expect([1, 2, 3]).to.include.members([1, 2]);
expect([1, 2, 3]).to.not.have.members([1, 2]);

// Duplicates in the subset are ignored
expect([1, 2, 3]).to.include.members([1, 2, 2, 2]);
</code></pre>
<p><code>.deep</code>, <code>.ordered</code>, and <code>.include</code> can all be combined. However, if
<code>.include</code> and <code>.ordered</code> are combined, the ordering begins at the start of
both arrays.</p>
<pre><code>expect([{a: 1}, {b: 2}, {c: 3}])
  .to.include.deep.ordered.members([{a: 1}, {b: 2}])
  .but.not.include.deep.ordered.members([{b: 2}, {c: 3}]);
</code></pre>
<p>Add <code>.not</code> earlier in the chain to negate <code>.members</code>. However, it's
dangerous to do so. The problem is that it creates uncertain expectations
by asserting that the target array doesn't have all of the same members as
the given array <code>set</code> but may or may not have some of them. It's often best
to identify the exact output that's expected, and then write an assertion
that only accepts that exact output.</p>
<pre><code>expect([1, 2]).to.not.include(3).and.not.include(4); // Recommended
expect([1, 2]).to.not.have.members([3, 4]); // Not recommended
</code></pre>
<p><code>.members</code> accepts an optional <code>msg</code> argument which is a custom error
message to show when the assertion fails. The message can also be given as
the second argument to <code>expect</code>.</p>
<pre><code>expect([1, 2]).to.have.members([1, 2, 3], 'nooo why fail??');
expect([1, 2], 'nooo why fail??').to.have.members([1, 2, 3]);</code></pre></div>
        

        


<dl class="details">

    

    

    

    

    

    

    

    

    

    

    

    
    

    

    

    
        <p class="tag-source">
            <a href="node_modules_chai_chai.js.html" class="button">View Source</a>
            <span>
                <a href="node_modules_chai_chai.js.html">node_modules/chai/chai.js</a>, <a href="node_modules_chai_chai.js.html#line3389">line 3389</a>
            </span>
        </p>
    
</dl>


        
    
    </div>
    
    

    

    

    

    

    

    

    

    

    
</article>

</section>







<section>

<header>
    
        <h2>BDD</h2>
        
    
</header>

<article>
    <div class="container-overview">
    
        
            <div class="description"><h3>.oneOf(list[, msg])</h3>
<p>Asserts that the target is a member of the given array <code>list</code>. However,
it's often best to assert that the target is equal to its expected value.</p>
<pre><code>expect(1).to.equal(1); // Recommended
expect(1).to.be.oneOf([1, 2, 3]); // Not recommended
</code></pre>
<p>Comparisons are performed using strict (<code>===</code>) equality.</p>
<p>Add <code>.not</code> earlier in the chain to negate <code>.oneOf</code>.</p>
<pre><code>expect(1).to.equal(1); // Recommended
expect(1).to.not.be.oneOf([2, 3, 4]); // Not recommended
</code></pre>
<p>It can also be chained with <code>.contain</code> or <code>.include</code>, which will work with
both arrays and strings:</p>
<pre><code>expect('Today is sunny').to.contain.oneOf(['sunny', 'cloudy'])
expect('Today is rainy').to.not.contain.oneOf(['sunny', 'cloudy'])
expect([1,2,3]).to.contain.oneOf([3,4,5])
expect([1,2,3]).to.not.contain.oneOf([4,5,6])
</code></pre>
<p><code>.oneOf</code> accepts an optional <code>msg</code> argument which is a custom error message
to show when the assertion fails. The message can also be given as the
second argument to <code>expect</code>.</p>
<pre><code>expect(1).to.be.oneOf([2, 3, 4], 'nooo why fail??');
expect(1, 'nooo why fail??').to.be.oneOf([2, 3, 4]);</code></pre></div>
        

        


<dl class="details">

    

    

    

    

    

    

    

    

    

    

    

    
    

    

    

    
        <p class="tag-source">
            <a href="node_modules_chai_chai.js.html" class="button">View Source</a>
            <span>
                <a href="node_modules_chai_chai.js.html">node_modules/chai/chai.js</a>, <a href="node_modules_chai_chai.js.html#line3494">line 3494</a>
            </span>
        </p>
    
</dl>


        
    
    </div>
    
    

    

    

    

    

    

    

    

    

    
</article>

</section>







<section>

<header>
    
        <h2>BDD</h2>
        
    
</header>

<article>
    <div class="container-overview">
    
        
            <div class="description"><h3>.change(subject[, prop[, msg]])</h3>
<p>When one argument is provided, <code>.change</code> asserts that the given function
<code>subject</code> returns a different value when it's invoked before the target
function compared to when it's invoked afterward. However, it's often best
to assert that <code>subject</code> is equal to its expected value.</p>
<pre><code>var dots = ''
  , addDot = function () { dots += '.'; }
  , getDots = function () { return dots; };

// Recommended
expect(getDots()).to.equal('');
addDot();
expect(getDots()).to.equal('.');

// Not recommended
expect(addDot).to.change(getDots);
</code></pre>
<p>When two arguments are provided, <code>.change</code> asserts that the value of the
given object <code>subject</code>'s <code>prop</code> property is different before invoking the
target function compared to afterward.</p>
<pre><code>var myObj = {dots: ''}
  , addDot = function () { myObj.dots += '.'; };

// Recommended
expect(myObj).to.have.property('dots', '');
addDot();
expect(myObj).to.have.property('dots', '.');

// Not recommended
expect(addDot).to.change(myObj, 'dots');
</code></pre>
<p>Strict (<code>===</code>) equality is used to compare before and after values.</p>
<p>Add <code>.not</code> earlier in the chain to negate <code>.change</code>.</p>
<pre><code>var dots = ''
  , noop = function () {}
  , getDots = function () { return dots; };

expect(noop).to.not.change(getDots);

var myObj = {dots: ''}
  , noop = function () {};

expect(noop).to.not.change(myObj, 'dots');
</code></pre>
<p><code>.change</code> accepts an optional <code>msg</code> argument which is a custom error
message to show when the assertion fails. The message can also be given as
the second argument to <code>expect</code>. When not providing two arguments, always
use the second form.</p>
<pre><code>var myObj = {dots: ''}
  , addDot = function () { myObj.dots += '.'; };

expect(addDot).to.not.change(myObj, 'dots', 'nooo why fail??');

var dots = ''
  , addDot = function () { dots += '.'; }
  , getDots = function () { return dots; };

expect(addDot, 'nooo why fail??').to.not.change(getDots);
</code></pre>
<p><code>.change</code> also causes all <code>.by</code> assertions that follow in the chain to
assert how much a numeric subject was increased or decreased by. However,
it's dangerous to use <code>.change.by</code>. The problem is that it creates
uncertain expectations by asserting that the subject either increases by
the given delta, or that it decreases by the given delta. It's often best
to identify the exact output that's expected, and then write an assertion
that only accepts that exact output.</p>
<pre><code>var myObj = {val: 1}
  , addTwo = function () { myObj.val += 2; }
  , subtractTwo = function () { myObj.val -= 2; };

expect(addTwo).to.increase(myObj, 'val').by(2); // Recommended
expect(addTwo).to.change(myObj, 'val').by(2); // Not recommended

expect(subtractTwo).to.decrease(myObj, 'val').by(2); // Recommended
expect(subtractTwo).to.change(myObj, 'val').by(2); // Not recommended
</code></pre>
<p>The alias <code>.changes</code> can be used interchangeably with <code>.change</code>.</p></div>
        

        


<dl class="details">

    

    

    

    

    

    

    

    

    

    

    

    
    

    

    

    
        <p class="tag-source">
            <a href="node_modules_chai_chai.js.html" class="button">View Source</a>
            <span>
                <a href="node_modules_chai_chai.js.html">node_modules/chai/chai.js</a>, <a href="node_modules_chai_chai.js.html#line3572">line 3572</a>
            </span>
        </p>
    
</dl>


        
    
    </div>
    
    

    

    

    

    

    

    

    

    

    
</article>

</section>







<section>

<header>
    
        <h2>BDD</h2>
        
    
</header>

<article>
    <div class="container-overview">
    
        
            <div class="description"><h3>.increase(subject[, prop[, msg]])</h3>
<p>When one argument is provided, <code>.increase</code> asserts that the given function
<code>subject</code> returns a greater number when it's invoked after invoking the
target function compared to when it's invoked beforehand. <code>.increase</code> also
causes all <code>.by</code> assertions that follow in the chain to assert how much
greater of a number is returned. It's often best to assert that the return
value increased by the expected amount, rather than asserting it increased
by any amount.</p>
<pre><code>var val = 1
  , addTwo = function () { val += 2; }
  , getVal = function () { return val; };

expect(addTwo).to.increase(getVal).by(2); // Recommended
expect(addTwo).to.increase(getVal); // Not recommended
</code></pre>
<p>When two arguments are provided, <code>.increase</code> asserts that the value of the
given object <code>subject</code>'s <code>prop</code> property is greater after invoking the
target function compared to beforehand.</p>
<pre><code>var myObj = {val: 1}
  , addTwo = function () { myObj.val += 2; };

expect(addTwo).to.increase(myObj, 'val').by(2); // Recommended
expect(addTwo).to.increase(myObj, 'val'); // Not recommended
</code></pre>
<p>Add <code>.not</code> earlier in the chain to negate <code>.increase</code>. However, it's
dangerous to do so. The problem is that it creates uncertain expectations
by asserting that the subject either decreases, or that it stays the same.
It's often best to identify the exact output that's expected, and then
write an assertion that only accepts that exact output.</p>
<p>When the subject is expected to decrease, it's often best to assert that it
decreased by the expected amount.</p>
<pre><code>var myObj = {val: 1}
  , subtractTwo = function () { myObj.val -= 2; };

expect(subtractTwo).to.decrease(myObj, 'val').by(2); // Recommended
expect(subtractTwo).to.not.increase(myObj, 'val'); // Not recommended
</code></pre>
<p>When the subject is expected to stay the same, it's often best to assert
exactly that.</p>
<pre><code>var myObj = {val: 1}
  , noop = function () {};

expect(noop).to.not.change(myObj, 'val'); // Recommended
expect(noop).to.not.increase(myObj, 'val'); // Not recommended
</code></pre>
<p><code>.increase</code> accepts an optional <code>msg</code> argument which is a custom error
message to show when the assertion fails. The message can also be given as
the second argument to <code>expect</code>. When not providing two arguments, always
use the second form.</p>
<pre><code>var myObj = {val: 1}
  , noop = function () {};

expect(noop).to.increase(myObj, 'val', 'nooo why fail??');

var val = 1
  , noop = function () {}
  , getVal = function () { return val; };

expect(noop, 'nooo why fail??').to.increase(getVal);
</code></pre>
<p>The alias <code>.increases</code> can be used interchangeably with <code>.increase</code>.</p></div>
        

        


<dl class="details">

    

    

    

    

    

    

    

    

    

    

    

    
    

    

    

    
        <p class="tag-source">
            <a href="node_modules_chai_chai.js.html" class="button">View Source</a>
            <span>
                <a href="node_modules_chai_chai.js.html">node_modules/chai/chai.js</a>, <a href="node_modules_chai_chai.js.html#line3705">line 3705</a>
            </span>
        </p>
    
</dl>


        
    
    </div>
    
    

    

    

    

    

    

    

    

    

    
</article>

</section>







<section>

<header>
    
        <h2>BDD</h2>
        
    
</header>

<article>
    <div class="container-overview">
    
        
            <div class="description"><h3>.decrease(subject[, prop[, msg]])</h3>
<p>When one argument is provided, <code>.decrease</code> asserts that the given function
<code>subject</code> returns a lesser number when it's invoked after invoking the
target function compared to when it's invoked beforehand. <code>.decrease</code> also
causes all <code>.by</code> assertions that follow in the chain to assert how much
lesser of a number is returned. It's often best to assert that the return
value decreased by the expected amount, rather than asserting it decreased
by any amount.</p>
<pre><code>var val = 1
  , subtractTwo = function () { val -= 2; }
  , getVal = function () { return val; };

expect(subtractTwo).to.decrease(getVal).by(2); // Recommended
expect(subtractTwo).to.decrease(getVal); // Not recommended
</code></pre>
<p>When two arguments are provided, <code>.decrease</code> asserts that the value of the
given object <code>subject</code>'s <code>prop</code> property is lesser after invoking the
target function compared to beforehand.</p>
<pre><code>var myObj = {val: 1}
  , subtractTwo = function () { myObj.val -= 2; };

expect(subtractTwo).to.decrease(myObj, 'val').by(2); // Recommended
expect(subtractTwo).to.decrease(myObj, 'val'); // Not recommended
</code></pre>
<p>Add <code>.not</code> earlier in the chain to negate <code>.decrease</code>. However, it's
dangerous to do so. The problem is that it creates uncertain expectations
by asserting that the subject either increases, or that it stays the same.
It's often best to identify the exact output that's expected, and then
write an assertion that only accepts that exact output.</p>
<p>When the subject is expected to increase, it's often best to assert that it
increased by the expected amount.</p>
<pre><code>var myObj = {val: 1}
  , addTwo = function () { myObj.val += 2; };

expect(addTwo).to.increase(myObj, 'val').by(2); // Recommended
expect(addTwo).to.not.decrease(myObj, 'val'); // Not recommended
</code></pre>
<p>When the subject is expected to stay the same, it's often best to assert
exactly that.</p>
<pre><code>var myObj = {val: 1}
  , noop = function () {};

expect(noop).to.not.change(myObj, 'val'); // Recommended
expect(noop).to.not.decrease(myObj, 'val'); // Not recommended
</code></pre>
<p><code>.decrease</code> accepts an optional <code>msg</code> argument which is a custom error
message to show when the assertion fails. The message can also be given as
the second argument to <code>expect</code>. When not providing two arguments, always
use the second form.</p>
<pre><code>var myObj = {val: 1}
  , noop = function () {};

expect(noop).to.decrease(myObj, 'val', 'nooo why fail??');

var val = 1
  , noop = function () {}
  , getVal = function () { return val; };

expect(noop, 'nooo why fail??').to.decrease(getVal);
</code></pre>
<p>The alias <code>.decreases</code> can be used interchangeably with <code>.decrease</code>.</p></div>
        

        


<dl class="details">

    

    

    

    

    

    

    

    

    

    

    

    
    

    

    

    
        <p class="tag-source">
            <a href="node_modules_chai_chai.js.html" class="button">View Source</a>
            <span>
                <a href="node_modules_chai_chai.js.html">node_modules/chai/chai.js</a>, <a href="node_modules_chai_chai.js.html#line3824">line 3824</a>
            </span>
        </p>
    
</dl>


        
    
    </div>
    
    

    

    

    

    

    

    

    

    

    
</article>

</section>







<section>

<header>
    
        <h2>BDD</h2>
        
    
</header>

<article>
    <div class="container-overview">
    
        
            <div class="description"><h3>.by(delta[, msg])</h3>
<p>When following an <code>.increase</code> assertion in the chain, <code>.by</code> asserts that
the subject of the <code>.increase</code> assertion increased by the given <code>delta</code>.</p>
<pre><code>var myObj = {val: 1}
  , addTwo = function () { myObj.val += 2; };

expect(addTwo).to.increase(myObj, 'val').by(2);
</code></pre>
<p>When following a <code>.decrease</code> assertion in the chain, <code>.by</code> asserts that the
subject of the <code>.decrease</code> assertion decreased by the given <code>delta</code>.</p>
<pre><code>var myObj = {val: 1}
  , subtractTwo = function () { myObj.val -= 2; };

expect(subtractTwo).to.decrease(myObj, 'val').by(2);
</code></pre>
<p>When following a <code>.change</code> assertion in the chain, <code>.by</code> asserts that the
subject of the <code>.change</code> assertion either increased or decreased by the
given <code>delta</code>. However, it's dangerous to use <code>.change.by</code>. The problem is
that it creates uncertain expectations. It's often best to identify the
exact output that's expected, and then write an assertion that only accepts
that exact output.</p>
<pre><code>var myObj = {val: 1}
  , addTwo = function () { myObj.val += 2; }
  , subtractTwo = function () { myObj.val -= 2; };

expect(addTwo).to.increase(myObj, 'val').by(2); // Recommended
expect(addTwo).to.change(myObj, 'val').by(2); // Not recommended

expect(subtractTwo).to.decrease(myObj, 'val').by(2); // Recommended
expect(subtractTwo).to.change(myObj, 'val').by(2); // Not recommended
</code></pre>
<p>Add <code>.not</code> earlier in the chain to negate <code>.by</code>. However, it's often best
to assert that the subject changed by its expected delta, rather than
asserting that it didn't change by one of countless unexpected deltas.</p>
<pre><code>var myObj = {val: 1}
  , addTwo = function () { myObj.val += 2; };

// Recommended
expect(addTwo).to.increase(myObj, 'val').by(2);

// Not recommended
expect(addTwo).to.increase(myObj, 'val').but.not.by(3);
</code></pre>
<p><code>.by</code> accepts an optional <code>msg</code> argument which is a custom error message to
show when the assertion fails. The message can also be given as the second
argument to <code>expect</code>.</p>
<pre><code>var myObj = {val: 1}
  , addTwo = function () { myObj.val += 2; };

expect(addTwo).to.increase(myObj, 'val').by(3, 'nooo why fail??');
expect(addTwo, 'nooo why fail??').to.increase(myObj, 'val').by(3);</code></pre></div>
        

        


<dl class="details">

    

    

    

    

    

    

    

    

    

    

    

    
    

    

    

    
        <p class="tag-source">
            <a href="node_modules_chai_chai.js.html" class="button">View Source</a>
            <span>
                <a href="node_modules_chai_chai.js.html">node_modules/chai/chai.js</a>, <a href="node_modules_chai_chai.js.html#line3943">line 3943</a>
            </span>
        </p>
    
</dl>


        
    
    </div>
    
    

    

    

    

    

    

    

    

    

    
</article>

</section>







<section>

<header>
    
        <h2>BDD</h2>
        
    
</header>

<article>
    <div class="container-overview">
    
        
            <div class="description"><h3>.extensible</h3>
<p>Asserts that the target is extensible, which means that new properties can
be added to it. Primitives are never extensible.</p>
<pre><code>expect({a: 1}).to.be.extensible;
</code></pre>
<p>Add <code>.not</code> earlier in the chain to negate <code>.extensible</code>.</p>
<pre><code>var nonExtensibleObject = Object.preventExtensions({})
  , sealedObject = Object.seal({})
  , frozenObject = Object.freeze({});

expect(nonExtensibleObject).to.not.be.extensible;
expect(sealedObject).to.not.be.extensible;
expect(frozenObject).to.not.be.extensible;
expect(1).to.not.be.extensible;
</code></pre>
<p>A custom error message can be given as the second argument to <code>expect</code>.</p>
<pre><code>expect(1, 'nooo why fail??').to.be.extensible;</code></pre></div>
        

        


<dl class="details">

    

    

    

    

    

    

    

    

    

    

    

    
    

    

    

    
        <p class="tag-source">
            <a href="node_modules_chai_chai.js.html" class="button">View Source</a>
            <span>
                <a href="node_modules_chai_chai.js.html">node_modules/chai/chai.js</a>, <a href="node_modules_chai_chai.js.html#line4034">line 4034</a>
            </span>
        </p>
    
</dl>


        
    
    </div>
    
    

    

    

    

    

    

    

    

    

    
</article>

</section>







<section>

<header>
    
        <h2>BDD</h2>
        
    
</header>

<article>
    <div class="container-overview">
    
        
            <div class="description"><h3>.sealed</h3>
<p>Asserts that the target is sealed, which means that new properties can't be
added to it, and its existing properties can't be reconfigured or deleted.
However, it's possible that its existing properties can still be reassigned
to different values. Primitives are always sealed.</p>
<pre><code>var sealedObject = Object.seal({});
var frozenObject = Object.freeze({});

expect(sealedObject).to.be.sealed;
expect(frozenObject).to.be.sealed;
expect(1).to.be.sealed;
</code></pre>
<p>Add <code>.not</code> earlier in the chain to negate <code>.sealed</code>.</p>
<pre><code>expect({a: 1}).to.not.be.sealed;
</code></pre>
<p>A custom error message can be given as the second argument to <code>expect</code>.</p>
<pre><code>expect({a: 1}, 'nooo why fail??').to.be.sealed;</code></pre></div>
        

        


<dl class="details">

    

    

    

    

    

    

    

    

    

    

    

    
    

    

    

    
        <p class="tag-source">
            <a href="node_modules_chai_chai.js.html" class="button">View Source</a>
            <span>
                <a href="node_modules_chai_chai.js.html">node_modules/chai/chai.js</a>, <a href="node_modules_chai_chai.js.html#line4079">line 4079</a>
            </span>
        </p>
    
</dl>


        
    
    </div>
    
    

    

    

    

    

    

    

    

    

    
</article>

</section>







<section>

<header>
    
        <h2>BDD</h2>
        
    
</header>

<article>
    <div class="container-overview">
    
        
            <div class="description"><h3>.frozen</h3>
<p>Asserts that the target is frozen, which means that new properties can't be
added to it, and its existing properties can't be reassigned to different
values, reconfigured, or deleted. Primitives are always frozen.</p>
<pre><code>var frozenObject = Object.freeze({});

expect(frozenObject).to.be.frozen;
expect(1).to.be.frozen;
</code></pre>
<p>Add <code>.not</code> earlier in the chain to negate <code>.frozen</code>.</p>
<pre><code>expect({a: 1}).to.not.be.frozen;
</code></pre>
<p>A custom error message can be given as the second argument to <code>expect</code>.</p>
<pre><code>expect({a: 1}, 'nooo why fail??').to.be.frozen;</code></pre></div>
        

        


<dl class="details">

    

    

    

    

    

    

    

    

    

    

    

    
    

    

    

    
        <p class="tag-source">
            <a href="node_modules_chai_chai.js.html" class="button">View Source</a>
            <span>
                <a href="node_modules_chai_chai.js.html">node_modules/chai/chai.js</a>, <a href="node_modules_chai_chai.js.html#line4124">line 4124</a>
            </span>
        </p>
    
</dl>


        
    
    </div>
    
    

    

    

    

    

    

    

    

    

    
</article>

</section>







<section>

<header>
    
        <h2>BDD</h2>
        
    
</header>

<article>
    <div class="container-overview">
    
        
            <div class="description"><h3>.finite</h3>
<p>Asserts that the target is a number, and isn't <code>NaN</code> or positive/negative
<code>Infinity</code>.</p>
<pre><code>expect(1).to.be.finite;
</code></pre>
<p>Add <code>.not</code> earlier in the chain to negate <code>.finite</code>. However, it's
dangerous to do so. The problem is that it creates uncertain expectations
by asserting that the subject either isn't a number, or that it's <code>NaN</code>, or
that it's positive <code>Infinity</code>, or that it's negative <code>Infinity</code>. It's often
best to identify the exact output that's expected, and then write an
assertion that only accepts that exact output.</p>
<p>When the target isn't expected to be a number, it's often best to assert
that it's the expected type, rather than asserting that it isn't one of
many unexpected types.</p>
<pre><code>expect('foo').to.be.a('string'); // Recommended
expect('foo').to.not.be.finite; // Not recommended
</code></pre>
<p>When the target is expected to be <code>NaN</code>, it's often best to assert exactly
that.</p>
<pre><code>expect(NaN).to.be.NaN; // Recommended
expect(NaN).to.not.be.finite; // Not recommended
</code></pre>
<p>When the target is expected to be positive infinity, it's often best to
assert exactly that.</p>
<pre><code>expect(Infinity).to.equal(Infinity); // Recommended
expect(Infinity).to.not.be.finite; // Not recommended
</code></pre>
<p>When the target is expected to be negative infinity, it's often best to
assert exactly that.</p>
<pre><code>expect(-Infinity).to.equal(-Infinity); // Recommended
expect(-Infinity).to.not.be.finite; // Not recommended
</code></pre>
<p>A custom error message can be given as the second argument to <code>expect</code>.</p>
<pre><code>expect('foo', 'nooo why fail??').to.be.finite;</code></pre></div>
        

        


<dl class="details">

    

    

    

    

    

    

    

    

    

    

    

    
    

    

    

    
        <p class="tag-source">
            <a href="node_modules_chai_chai.js.html" class="button">View Source</a>
            <span>
                <a href="node_modules_chai_chai.js.html">node_modules/chai/chai.js</a>, <a href="node_modules_chai_chai.js.html#line4166">line 4166</a>
            </span>
        </p>
    
</dl>


        
    
    </div>
    
    

    

    

    

    

    

    

    

    

    
</article>

</section>







<section>

<header>
    
        <h2>BDD</h2>
        
    
</header>

<article>
    <div class="container-overview">
    
        
            <div class="description"><h3>.fail([message])</h3>
<h3>.fail(actual, expected, [message], [operator])</h3>
<p>Throw a failure.</p>
<pre><code>expect.fail();
expect.fail(&quot;custom error message&quot;);
expect.fail(1, 2);
expect.fail(1, 2, &quot;custom error message&quot;);
expect.fail(1, 2, &quot;custom error message&quot;, &quot;&gt;&quot;);
expect.fail(1, 2, undefined, &quot;&gt;&quot;);</code></pre></div>
        

        


<dl class="details">

    

    

    

    

    

    

    

    

    

    

    

    
    

    

    

    
        <p class="tag-source">
            <a href="node_modules_chai_chai.js.html" class="button">View Source</a>
            <span>
                <a href="node_modules_chai_chai.js.html">node_modules/chai/chai.js</a>, <a href="node_modules_chai_chai.js.html#line7353">line 7353</a>
            </span>
        </p>
    
</dl>


        
    
    </div>
    
    

    

    

    

    

    

    

    

    

    
</article>

</section>







<section>

<header>
    
        <h2>BDD</h2>
        
    
</header>

<article>
    <div class="container-overview">
    
        
            <div class="description"><h3>.fail([message])</h3>
<h3>.fail(actual, expected, [message], [operator])</h3>
<p>Throw a failure.</p>
<pre><code>should.fail();
should.fail(&quot;custom error message&quot;);
should.fail(1, 2);
should.fail(1, 2, &quot;custom error message&quot;);
should.fail(1, 2, &quot;custom error message&quot;, &quot;&gt;&quot;);
should.fail(1, 2, undefined, &quot;&gt;&quot;);</code></pre></div>
        

        


<dl class="details">

    

    

    

    

    

    

    

    

    

    

    

    
    

    

    

    
        <p class="tag-source">
            <a href="node_modules_chai_chai.js.html" class="button">View Source</a>
            <span>
                <a href="node_modules_chai_chai.js.html">node_modules/chai/chai.js</a>, <a href="node_modules_chai_chai.js.html#line7435">line 7435</a>
            </span>
        </p>
    
</dl>


        
    
    </div>
    
    

    

    

    

    

    

    

    

    

    
</article>

</section>







<section>

<header>
    
        <h2>BDD</h2>
        
    
</header>

<article>
    <div class="container-overview">
    
        
            <div class="description"><h3>Language Chains</h3>
<p>The following are provided as chainable getters to improve the readability
of your assertions.</p>
<p><strong>Chains</strong></p>
<ul>
<li>to</li>
<li>be</li>
<li>been</li>
<li>is</li>
<li>that</li>
<li>which</li>
<li>and</li>
<li>has</li>
<li>have</li>
<li>with</li>
<li>at</li>
<li>of</li>
<li>same</li>
<li>but</li>
<li>does</li>
<li>still</li>
<li>also</li>
</ul></div>
        

        


<dl class="details">

    

    

    

    

    

    

    

    

    

    

    

    
    

    

    

    
        <p class="tag-source">
            <a href="node_modules_chai_lib_chai_core_assertions.js.html" class="button">View Source</a>
            <span>
                <a href="node_modules_chai_lib_chai_core_assertions.js.html">node_modules/chai/lib/chai/core/assertions.js</a>, <a href="node_modules_chai_lib_chai_core_assertions.js.html#line13">line 13</a>
            </span>
        </p>
    
</dl>


        
    
    </div>
    
    

    

    

    

    

    

    

    

    

    
</article>

</section>







<section>

<header>
    
        <h2>BDD</h2>
        
    
</header>

<article>
    <div class="container-overview">
    
        
            <div class="description"><h3>.not</h3>
<p>Negates all assertions that follow in the chain.</p>
<pre><code>expect(function () {}).to.not.throw();
expect({a: 1}).to.not.have.property('b');
expect([1, 2]).to.be.an('array').that.does.not.include(3);
</code></pre>
<p>Just because you can negate any assertion with <code>.not</code> doesn't mean you
should. With great power comes great responsibility. It's often best to
assert that the one expected output was produced, rather than asserting
that one of countless unexpected outputs wasn't produced. See individual
assertions for specific guidance.</p>
<pre><code>expect(2).to.equal(2); // Recommended
expect(2).to.not.equal(1); // Not recommended</code></pre></div>
        

        


<dl class="details">

    

    

    

    

    

    

    

    

    

    

    

    
    

    

    

    
        <p class="tag-source">
            <a href="node_modules_chai_lib_chai_core_assertions.js.html" class="button">View Source</a>
            <span>
                <a href="node_modules_chai_lib_chai_core_assertions.js.html">node_modules/chai/lib/chai/core/assertions.js</a>, <a href="node_modules_chai_lib_chai_core_assertions.js.html#line51">line 51</a>
            </span>
        </p>
    
</dl>


        
    
    </div>
    
    

    

    

    

    

    

    

    

    

    
</article>

</section>







<section>

<header>
    
        <h2>BDD</h2>
        
    
</header>

<article>
    <div class="container-overview">
    
        
            <div class="description"><h3>.deep</h3>
<p>Causes all <code>.equal</code>, <code>.include</code>, <code>.members</code>, <code>.keys</code>, and <code>.property</code>
assertions that follow in the chain to use deep equality instead of strict
(<code>===</code>) equality. See the <code>deep-eql</code> project page for info on the deep
equality algorithm: https://github.com/chaijs/deep-eql.</p>
<pre><code>// Target object deeply (but not strictly) equals `{a: 1}`
expect({a: 1}).to.deep.equal({a: 1});
expect({a: 1}).to.not.equal({a: 1});

// Target array deeply (but not strictly) includes `{a: 1}`
expect([{a: 1}]).to.deep.include({a: 1});
expect([{a: 1}]).to.not.include({a: 1});

// Target object deeply (but not strictly) includes `x: {a: 1}`
expect({x: {a: 1}}).to.deep.include({x: {a: 1}});
expect({x: {a: 1}}).to.not.include({x: {a: 1}});

// Target array deeply (but not strictly) has member `{a: 1}`
expect([{a: 1}]).to.have.deep.members([{a: 1}]);
expect([{a: 1}]).to.not.have.members([{a: 1}]);

// Target set deeply (but not strictly) has key `{a: 1}`
expect(new Set([{a: 1}])).to.have.deep.keys([{a: 1}]);
expect(new Set([{a: 1}])).to.not.have.keys([{a: 1}]);

// Target object deeply (but not strictly) has property `x: {a: 1}`
expect({x: {a: 1}}).to.have.deep.property('x', {a: 1});
expect({x: {a: 1}}).to.not.have.property('x', {a: 1});</code></pre></div>
        

        


<dl class="details">

    

    

    

    

    

    

    

    

    

    

    

    
    

    

    

    
        <p class="tag-source">
            <a href="node_modules_chai_lib_chai_core_assertions.js.html" class="button">View Source</a>
            <span>
                <a href="node_modules_chai_lib_chai_core_assertions.js.html">node_modules/chai/lib/chai/core/assertions.js</a>, <a href="node_modules_chai_lib_chai_core_assertions.js.html#line78">line 78</a>
            </span>
        </p>
    
</dl>


        
    
    </div>
    
    

    

    

    

    

    

    

    

    

    
</article>

</section>







<section>

<header>
    
        <h2>BDD</h2>
        
    
</header>

<article>
    <div class="container-overview">
    
        
            <div class="description"><h3>.nested</h3>
<p>Enables dot- and bracket-notation in all <code>.property</code> and <code>.include</code>
assertions that follow in the chain.</p>
<pre><code>expect({a: {b: ['x', 'y']}}).to.have.nested.property('a.b[1]');
expect({a: {b: ['x', 'y']}}).to.nested.include({'a.b[1]': 'y'});
</code></pre>
<p>If <code>.</code> or <code>[]</code> are part of an actual property name, they can be escaped by
adding two backslashes before them.</p>
<pre><code>expect({'.a': {'[b]': 'x'}}).to.have.nested.property('\\.a.\\[b\\]');
expect({'.a': {'[b]': 'x'}}).to.nested.include({'\\.a.\\[b\\]': 'x'});
</code></pre>
<p><code>.nested</code> cannot be combined with <code>.own</code>.</p></div>
        

        


<dl class="details">

    

    

    

    

    

    

    

    

    

    

    

    
    

    

    

    
        <p class="tag-source">
            <a href="node_modules_chai_lib_chai_core_assertions.js.html" class="button">View Source</a>
            <span>
                <a href="node_modules_chai_lib_chai_core_assertions.js.html">node_modules/chai/lib/chai/core/assertions.js</a>, <a href="node_modules_chai_lib_chai_core_assertions.js.html#line119">line 119</a>
            </span>
        </p>
    
</dl>


        
    
    </div>
    
    

    

    

    

    

    

    

    

    

    
</article>

</section>







<section>

<header>
    
        <h2>BDD</h2>
        
    
</header>

<article>
    <div class="container-overview">
    
        
            <div class="description"><h3>.own</h3>
<p>Causes all <code>.property</code> and <code>.include</code> assertions that follow in the chain
to ignore inherited properties.</p>
<pre><code>Object.prototype.b = 2;

expect({a: 1}).to.have.own.property('a');
expect({a: 1}).to.have.property('b');
expect({a: 1}).to.not.have.own.property('b');

expect({a: 1}).to.own.include({a: 1});
expect({a: 1}).to.include({b: 2}).but.not.own.include({b: 2});
</code></pre>
<p><code>.own</code> cannot be combined with <code>.nested</code>.</p></div>
        

        


<dl class="details">

    

    

    

    

    

    

    

    

    

    

    

    
    

    

    

    
        <p class="tag-source">
            <a href="node_modules_chai_lib_chai_core_assertions.js.html" class="button">View Source</a>
            <span>
                <a href="node_modules_chai_lib_chai_core_assertions.js.html">node_modules/chai/lib/chai/core/assertions.js</a>, <a href="node_modules_chai_lib_chai_core_assertions.js.html#line145">line 145</a>
            </span>
        </p>
    
</dl>


        
    
    </div>
    
    

    

    

    

    

    

    

    

    

    
</article>

</section>







<section>

<header>
    
        <h2>BDD</h2>
        
    
</header>

<article>
    <div class="container-overview">
    
        
            <div class="description"><h3>.ordered</h3>
<p>Causes all <code>.members</code> assertions that follow in the chain to require that
members be in the same order.</p>
<pre><code>expect([1, 2]).to.have.ordered.members([1, 2])
  .but.not.have.ordered.members([2, 1]);
</code></pre>
<p>When <code>.include</code> and <code>.ordered</code> are combined, the ordering begins at the
start of both arrays.</p>
<pre><code>expect([1, 2, 3]).to.include.ordered.members([1, 2])
  .but.not.include.ordered.members([2, 3]);</code></pre></div>
        

        


<dl class="details">

    

    

    

    

    

    

    

    

    

    

    

    
    

    

    

    
        <p class="tag-source">
            <a href="node_modules_chai_lib_chai_core_assertions.js.html" class="button">View Source</a>
            <span>
                <a href="node_modules_chai_lib_chai_core_assertions.js.html">node_modules/chai/lib/chai/core/assertions.js</a>, <a href="node_modules_chai_lib_chai_core_assertions.js.html#line171">line 171</a>
            </span>
        </p>
    
</dl>


        
    
    </div>
    
    

    

    

    

    

    

    

    

    

    
</article>

</section>







<section>

<header>
    
        <h2>BDD</h2>
        
    
</header>

<article>
    <div class="container-overview">
    
        
            <div class="description"><h3>.any</h3>
<p>Causes all <code>.keys</code> assertions that follow in the chain to only require that
the target have at least one of the given keys. This is the opposite of
<code>.all</code>, which requires that the target have all of the given keys.</p>
<pre><code>expect({a: 1, b: 2}).to.not.have.any.keys('c', 'd');
</code></pre>
<p>See the <code>.keys</code> doc for guidance on when to use <code>.any</code> or <code>.all</code>.</p></div>
        

        


<dl class="details">

    

    

    

    

    

    

    

    

    

    

    

    
    

    

    

    
        <p class="tag-source">
            <a href="node_modules_chai_lib_chai_core_assertions.js.html" class="button">View Source</a>
            <span>
                <a href="node_modules_chai_lib_chai_core_assertions.js.html">node_modules/chai/lib/chai/core/assertions.js</a>, <a href="node_modules_chai_lib_chai_core_assertions.js.html#line195">line 195</a>
            </span>
        </p>
    
</dl>


        
    
    </div>
    
    

    

    

    

    

    

    

    

    

    
</article>

</section>







<section>

<header>
    
        <h2>BDD</h2>
        
    
</header>

<article>
    <div class="container-overview">
    
        
            <div class="description"><h3>.all</h3>
<p>Causes all <code>.keys</code> assertions that follow in the chain to require that the
target have all of the given keys. This is the opposite of <code>.any</code>, which
only requires that the target have at least one of the given keys.</p>
<pre><code>expect({a: 1, b: 2}).to.have.all.keys('a', 'b');
</code></pre>
<p>Note that <code>.all</code> is used by default when neither <code>.all</code> nor <code>.any</code> are
added earlier in the chain. However, it's often best to add <code>.all</code> anyway
because it improves readability.</p>
<p>See the <code>.keys</code> doc for guidance on when to use <code>.any</code> or <code>.all</code>.</p></div>
        

        


<dl class="details">

    

    

    

    

    

    

    

    

    

    

    

    
    

    

    

    
        <p class="tag-source">
            <a href="node_modules_chai_lib_chai_core_assertions.js.html" class="button">View Source</a>
            <span>
                <a href="node_modules_chai_lib_chai_core_assertions.js.html">node_modules/chai/lib/chai/core/assertions.js</a>, <a href="node_modules_chai_lib_chai_core_assertions.js.html#line216">line 216</a>
            </span>
        </p>
    
</dl>


        
    
    </div>
    
    

    

    

    

    

    

    

    

    

    
</article>

</section>







<section>

<header>
    
        <h2>BDD</h2>
        
    
</header>

<article>
    <div class="container-overview">
    
        
            <div class="description"><h3>.a(type[, msg])</h3>
<p>Asserts that the target's type is equal to the given string <code>type</code>. Types
are case insensitive. See the <code>type-detect</code> project page for info on the
type detection algorithm: https://github.com/chaijs/type-detect.</p>
<pre><code>expect('foo').to.be.a('string');
expect({a: 1}).to.be.an('object');
expect(null).to.be.a('null');
expect(undefined).to.be.an('undefined');
expect(new Error).to.be.an('error');
expect(Promise.resolve()).to.be.a('promise');
expect(new Float32Array).to.be.a('float32array');
expect(Symbol()).to.be.a('symbol');
</code></pre>
<p><code>.a</code> supports objects that have a custom type set via <code>Symbol.toStringTag</code>.</p>
<pre><code>var myObj = {
  [Symbol.toStringTag]: 'myCustomType'
};

expect(myObj).to.be.a('myCustomType').but.not.an('object');
</code></pre>
<p>It's often best to use <code>.a</code> to check a target's type before making more
assertions on the same target. That way, you avoid unexpected behavior from
any assertion that does different things based on the target's type.</p>
<pre><code>expect([1, 2, 3]).to.be.an('array').that.includes(2);
expect([]).to.be.an('array').that.is.empty;
</code></pre>
<p>Add <code>.not</code> earlier in the chain to negate <code>.a</code>. However, it's often best to
assert that the target is the expected type, rather than asserting that it
isn't one of many unexpected types.</p>
<pre><code>expect('foo').to.be.a('string'); // Recommended
expect('foo').to.not.be.an('array'); // Not recommended
</code></pre>
<p><code>.a</code> accepts an optional <code>msg</code> argument which is a custom error message to
show when the assertion fails. The message can also be given as the second
argument to <code>expect</code>.</p>
<pre><code>expect(1).to.be.a('string', 'nooo why fail??');
expect(1, 'nooo why fail??').to.be.a('string');
</code></pre>
<p><code>.a</code> can also be used as a language chain to improve the readability of
your assertions.</p>
<pre><code>expect({b: 2}).to.have.a.property('b');
</code></pre>
<p>The alias <code>.an</code> can be used interchangeably with <code>.a</code>.</p></div>
        

        


<dl class="details">

    

    

    

    

    

    

    

    

    

    

    

    
    

    

    

    
        <p class="tag-source">
            <a href="node_modules_chai_lib_chai_core_assertions.js.html" class="button">View Source</a>
            <span>
                <a href="node_modules_chai_lib_chai_core_assertions.js.html">node_modules/chai/lib/chai/core/assertions.js</a>, <a href="node_modules_chai_lib_chai_core_assertions.js.html#line241">line 241</a>
            </span>
        </p>
    
</dl>


        
    
    </div>
    
    

    

    

    

    

    

    

    

    

    
</article>

</section>







<section>

<header>
    
        <h2>BDD</h2>
        
    
</header>

<article>
    <div class="container-overview">
    
        
            <div class="description"><h3>.include(val[, msg])</h3>
<p>When the target is a string, <code>.include</code> asserts that the given string <code>val</code>
is a substring of the target.</p>
<pre><code>expect('foobar').to.include('foo');
</code></pre>
<p>When the target is an array, <code>.include</code> asserts that the given <code>val</code> is a
member of the target.</p>
<pre><code>expect([1, 2, 3]).to.include(2);
</code></pre>
<p>When the target is an object, <code>.include</code> asserts that the given object
<code>val</code>'s properties are a subset of the target's properties.</p>
<pre><code>expect({a: 1, b: 2, c: 3}).to.include({a: 1, b: 2});
</code></pre>
<p>When the target is a Set or WeakSet, <code>.include</code> asserts that the given <code>val</code> is a
member of the target. SameValueZero equality algorithm is used.</p>
<pre><code>expect(new Set([1, 2])).to.include(2);
</code></pre>
<p>When the target is a Map, <code>.include</code> asserts that the given <code>val</code> is one of
the values of the target. SameValueZero equality algorithm is used.</p>
<pre><code>expect(new Map([['a', 1], ['b', 2]])).to.include(2);
</code></pre>
<p>Because <code>.include</code> does different things based on the target's type, it's
important to check the target's type before using <code>.include</code>. See the <code>.a</code>
doc for info on testing a target's type.</p>
<pre><code>expect([1, 2, 3]).to.be.an('array').that.includes(2);
</code></pre>
<p>By default, strict (<code>===</code>) equality is used to compare array members and
object properties. Add <code>.deep</code> earlier in the chain to use deep equality
instead (WeakSet targets are not supported). See the <code>deep-eql</code> project
page for info on the deep equality algorithm: https://github.com/chaijs/deep-eql.</p>
<pre><code>// Target array deeply (but not strictly) includes `{a: 1}`
expect([{a: 1}]).to.deep.include({a: 1});
expect([{a: 1}]).to.not.include({a: 1});

// Target object deeply (but not strictly) includes `x: {a: 1}`
expect({x: {a: 1}}).to.deep.include({x: {a: 1}});
expect({x: {a: 1}}).to.not.include({x: {a: 1}});
</code></pre>
<p>By default, all of the target's properties are searched when working with
objects. This includes properties that are inherited and/or non-enumerable.
Add <code>.own</code> earlier in the chain to exclude the target's inherited
properties from the search.</p>
<pre><code>Object.prototype.b = 2;

expect({a: 1}).to.own.include({a: 1});
expect({a: 1}).to.include({b: 2}).but.not.own.include({b: 2});
</code></pre>
<p>Note that a target object is always only searched for <code>val</code>'s own
enumerable properties.</p>
<p><code>.deep</code> and <code>.own</code> can be combined.</p>
<pre><code>expect({a: {b: 2}}).to.deep.own.include({a: {b: 2}});
</code></pre>
<p>Add <code>.nested</code> earlier in the chain to enable dot- and bracket-notation when
referencing nested properties.</p>
<pre><code>expect({a: {b: ['x', 'y']}}).to.nested.include({'a.b[1]': 'y'});
</code></pre>
<p>If <code>.</code> or <code>[]</code> are part of an actual property name, they can be escaped by
adding two backslashes before them.</p>
<pre><code>expect({'.a': {'[b]': 2}}).to.nested.include({'\\.a.\\[b\\]': 2});
</code></pre>
<p><code>.deep</code> and <code>.nested</code> can be combined.</p>
<pre><code>expect({a: {b: [{c: 3}]}}).to.deep.nested.include({'a.b[0]': {c: 3}});
</code></pre>
<p><code>.own</code> and <code>.nested</code> cannot be combined.</p>
<p>Add <code>.not</code> earlier in the chain to negate <code>.include</code>.</p>
<pre><code>expect('foobar').to.not.include('taco');
expect([1, 2, 3]).to.not.include(4);
</code></pre>
<p>However, it's dangerous to negate <code>.include</code> when the target is an object.
The problem is that it creates uncertain expectations by asserting that the
target object doesn't have all of <code>val</code>'s key/value pairs but may or may
not have some of them. It's often best to identify the exact output that's
expected, and then write an assertion that only accepts that exact output.</p>
<p>When the target object isn't even expected to have <code>val</code>'s keys, it's
often best to assert exactly that.</p>
<pre><code>expect({c: 3}).to.not.have.any.keys('a', 'b'); // Recommended
expect({c: 3}).to.not.include({a: 1, b: 2}); // Not recommended
</code></pre>
<p>When the target object is expected to have <code>val</code>'s keys, it's often best to
assert that each of the properties has its expected value, rather than
asserting that each property doesn't have one of many unexpected values.</p>
<pre><code>expect({a: 3, b: 4}).to.include({a: 3, b: 4}); // Recommended
expect({a: 3, b: 4}).to.not.include({a: 1, b: 2}); // Not recommended
</code></pre>
<p><code>.include</code> accepts an optional <code>msg</code> argument which is a custom error
message to show when the assertion fails. The message can also be given as
the second argument to <code>expect</code>.</p>
<pre><code>expect([1, 2, 3]).to.include(4, 'nooo why fail??');
expect([1, 2, 3], 'nooo why fail??').to.include(4);
</code></pre>
<p><code>.include</code> can also be used as a language chain, causing all <code>.members</code> and
<code>.keys</code> assertions that follow in the chain to require the target to be a
superset of the expected set, rather than an identical set. Note that
<code>.members</code> ignores duplicates in the subset when <code>.include</code> is added.</p>
<pre><code>// Target object's keys are a superset of ['a', 'b'] but not identical
expect({a: 1, b: 2, c: 3}).to.include.all.keys('a', 'b');
expect({a: 1, b: 2, c: 3}).to.not.have.all.keys('a', 'b');

// Target array is a superset of [1, 2] but not identical
expect([1, 2, 3]).to.include.members([1, 2]);
expect([1, 2, 3]).to.not.have.members([1, 2]);

// Duplicates in the subset are ignored
expect([1, 2, 3]).to.include.members([1, 2, 2, 2]);
</code></pre>
<p>Note that adding <code>.any</code> earlier in the chain causes the <code>.keys</code> assertion
to ignore <code>.include</code>.</p>
<pre><code>// Both assertions are identical
expect({a: 1}).to.include.any.keys('a', 'b');
expect({a: 1}).to.have.any.keys('a', 'b');
</code></pre>
<p>The aliases <code>.includes</code>, <code>.contain</code>, and <code>.contains</code> can be used
interchangeably with <code>.include</code>.</p></div>
        

        


<dl class="details">

    

    

    

    

    

    

    

    

    

    

    

    
    

    

    

    
        <p class="tag-source">
            <a href="node_modules_chai_lib_chai_core_assertions.js.html" class="button">View Source</a>
            <span>
                <a href="node_modules_chai_lib_chai_core_assertions.js.html">node_modules/chai/lib/chai/core/assertions.js</a>, <a href="node_modules_chai_lib_chai_core_assertions.js.html#line317">line 317</a>
            </span>
        </p>
    
</dl>


        
    
    </div>
    
    

    

    

    

    

    

    

    

    

    
</article>

</section>







<section>

<header>
    
        <h2>BDD</h2>
        
    
</header>

<article>
    <div class="container-overview">
    
        
            <div class="description"><h3>.ok</h3>
<p>Asserts that the target is a truthy value (considered <code>true</code> in boolean context).
However, it's often best to assert that the target is strictly (<code>===</code>) or
deeply equal to its expected value.</p>
<pre><code>expect(1).to.equal(1); // Recommended
expect(1).to.be.ok; // Not recommended

expect(true).to.be.true; // Recommended
expect(true).to.be.ok; // Not recommended
</code></pre>
<p>Add <code>.not</code> earlier in the chain to negate <code>.ok</code>.</p>
<pre><code>expect(0).to.equal(0); // Recommended
expect(0).to.not.be.ok; // Not recommended

expect(false).to.be.false; // Recommended
expect(false).to.not.be.ok; // Not recommended

expect(null).to.be.null; // Recommended
expect(null).to.not.be.ok; // Not recommended

expect(undefined).to.be.undefined; // Recommended
expect(undefined).to.not.be.ok; // Not recommended
</code></pre>
<p>A custom error message can be given as the second argument to <code>expect</code>.</p>
<pre><code>expect(false, 'nooo why fail??').to.be.ok;</code></pre></div>
        

        


<dl class="details">

    

    

    

    

    

    

    

    

    

    

    

    
    

    

    

    
        <p class="tag-source">
            <a href="node_modules_chai_lib_chai_core_assertions.js.html" class="button">View Source</a>
            <span>
                <a href="node_modules_chai_lib_chai_core_assertions.js.html">node_modules/chai/lib/chai/core/assertions.js</a>, <a href="node_modules_chai_lib_chai_core_assertions.js.html#line596">line 596</a>
            </span>
        </p>
    
</dl>


        
    
    </div>
    
    

    

    

    

    

    

    

    

    

    
</article>

</section>







<section>

<header>
    
        <h2>BDD</h2>
        
    
</header>

<article>
    <div class="container-overview">
    
        
            <div class="description"><h3>.true</h3>
<p>Asserts that the target is strictly (<code>===</code>) equal to <code>true</code>.</p>
<pre><code>expect(true).to.be.true;
</code></pre>
<p>Add <code>.not</code> earlier in the chain to negate <code>.true</code>. However, it's often best
to assert that the target is equal to its expected value, rather than not
equal to <code>true</code>.</p>
<pre><code>expect(false).to.be.false; // Recommended
expect(false).to.not.be.true; // Not recommended

expect(1).to.equal(1); // Recommended
expect(1).to.not.be.true; // Not recommended
</code></pre>
<p>A custom error message can be given as the second argument to <code>expect</code>.</p>
<pre><code>expect(false, 'nooo why fail??').to.be.true;</code></pre></div>
        

        


<dl class="details">

    

    

    

    

    

    

    

    

    

    

    

    
    

    

    

    
        <p class="tag-source">
            <a href="node_modules_chai_lib_chai_core_assertions.js.html" class="button">View Source</a>
            <span>
                <a href="node_modules_chai_lib_chai_core_assertions.js.html">node_modules/chai/lib/chai/core/assertions.js</a>, <a href="node_modules_chai_lib_chai_core_assertions.js.html#line639">line 639</a>
            </span>
        </p>
    
</dl>


        
    
    </div>
    
    

    

    

    

    

    

    

    

    

    
</article>

</section>







<section>

<header>
    
        <h2>BDD</h2>
        
    
</header>

<article>
    <div class="container-overview">
    
        
            <div class="description"><h3>.false</h3>
<p>Asserts that the target is strictly (<code>===</code>) equal to <code>false</code>.</p>
<pre><code>expect(false).to.be.false;
</code></pre>
<p>Add <code>.not</code> earlier in the chain to negate <code>.false</code>. However, it's often
best to assert that the target is equal to its expected value, rather than
not equal to <code>false</code>.</p>
<pre><code>expect(true).to.be.true; // Recommended
expect(true).to.not.be.false; // Not recommended

expect(1).to.equal(1); // Recommended
expect(1).to.not.be.false; // Not recommended
</code></pre>
<p>A custom error message can be given as the second argument to <code>expect</code>.</p>
<pre><code>expect(true, 'nooo why fail??').to.be.false;</code></pre></div>
        

        


<dl class="details">

    

    

    

    

    

    

    

    

    

    

    

    
    

    

    

    
        <p class="tag-source">
            <a href="node_modules_chai_lib_chai_core_assertions.js.html" class="button">View Source</a>
            <span>
                <a href="node_modules_chai_lib_chai_core_assertions.js.html">node_modules/chai/lib/chai/core/assertions.js</a>, <a href="node_modules_chai_lib_chai_core_assertions.js.html#line674">line 674</a>
            </span>
        </p>
    
</dl>


        
    
    </div>
    
    

    

    

    

    

    

    

    

    

    
</article>

</section>







<section>

<header>
    
        <h2>BDD</h2>
        
    
</header>

<article>
    <div class="container-overview">
    
        
            <div class="description"><h3>.null</h3>
<p>Asserts that the target is strictly (<code>===</code>) equal to <code>null</code>.</p>
<pre><code>expect(null).to.be.null;
</code></pre>
<p>Add <code>.not</code> earlier in the chain to negate <code>.null</code>. However, it's often best
to assert that the target is equal to its expected value, rather than not
equal to <code>null</code>.</p>
<pre><code>expect(1).to.equal(1); // Recommended
expect(1).to.not.be.null; // Not recommended
</code></pre>
<p>A custom error message can be given as the second argument to <code>expect</code>.</p>
<pre><code>expect(42, 'nooo why fail??').to.be.null;</code></pre></div>
        

        


<dl class="details">

    

    

    

    

    

    

    

    

    

    

    

    
    

    

    

    
        <p class="tag-source">
            <a href="node_modules_chai_lib_chai_core_assertions.js.html" class="button">View Source</a>
            <span>
                <a href="node_modules_chai_lib_chai_core_assertions.js.html">node_modules/chai/lib/chai/core/assertions.js</a>, <a href="node_modules_chai_lib_chai_core_assertions.js.html#line709">line 709</a>
            </span>
        </p>
    
</dl>


        
    
    </div>
    
    

    

    

    

    

    

    

    

    

    
</article>

</section>







<section>

<header>
    
        <h2>BDD</h2>
        
    
</header>

<article>
    <div class="container-overview">
    
        
            <div class="description"><h3>.undefined</h3>
<p>Asserts that the target is strictly (<code>===</code>) equal to <code>undefined</code>.</p>
<pre><code>expect(undefined).to.be.undefined;
</code></pre>
<p>Add <code>.not</code> earlier in the chain to negate <code>.undefined</code>. However, it's often
best to assert that the target is equal to its expected value, rather than
not equal to <code>undefined</code>.</p>
<pre><code>expect(1).to.equal(1); // Recommended
expect(1).to.not.be.undefined; // Not recommended
</code></pre>
<p>A custom error message can be given as the second argument to <code>expect</code>.</p>
<pre><code>expect(42, 'nooo why fail??').to.be.undefined;</code></pre></div>
        

        


<dl class="details">

    

    

    

    

    

    

    

    

    

    

    

    
    

    

    

    
        <p class="tag-source">
            <a href="node_modules_chai_lib_chai_core_assertions.js.html" class="button">View Source</a>
            <span>
                <a href="node_modules_chai_lib_chai_core_assertions.js.html">node_modules/chai/lib/chai/core/assertions.js</a>, <a href="node_modules_chai_lib_chai_core_assertions.js.html#line740">line 740</a>
            </span>
        </p>
    
</dl>


        
    
    </div>
    
    

    

    

    

    

    

    

    

    

    
</article>

</section>







<section>

<header>
    
        <h2>BDD</h2>
        
    
</header>

<article>
    <div class="container-overview">
    
        
            <div class="description"><h3>.NaN</h3>
<p>Asserts that the target is exactly <code>NaN</code>.</p>
<pre><code>expect(NaN).to.be.NaN;
</code></pre>
<p>Add <code>.not</code> earlier in the chain to negate <code>.NaN</code>. However, it's often best
to assert that the target is equal to its expected value, rather than not
equal to <code>NaN</code>.</p>
<pre><code>expect('foo').to.equal('foo'); // Recommended
expect('foo').to.not.be.NaN; // Not recommended
</code></pre>
<p>A custom error message can be given as the second argument to <code>expect</code>.</p>
<pre><code>expect(42, 'nooo why fail??').to.be.NaN;</code></pre></div>
        

        


<dl class="details">

    

    

    

    

    

    

    

    

    

    

    

    
    

    

    

    
        <p class="tag-source">
            <a href="node_modules_chai_lib_chai_core_assertions.js.html" class="button">View Source</a>
            <span>
                <a href="node_modules_chai_lib_chai_core_assertions.js.html">node_modules/chai/lib/chai/core/assertions.js</a>, <a href="node_modules_chai_lib_chai_core_assertions.js.html#line771">line 771</a>
            </span>
        </p>
    
</dl>


        
    
    </div>
    
    

    

    

    

    

    

    

    

    

    
</article>

</section>







<section>

<header>
    
        <h2>BDD</h2>
        
    
</header>

<article>
    <div class="container-overview">
    
        
            <div class="description"><h3>.exist</h3>
<p>Asserts that the target is not strictly (<code>===</code>) equal to either <code>null</code> or
<code>undefined</code>. However, it's often best to assert that the target is equal to
its expected value.</p>
<pre><code>expect(1).to.equal(1); // Recommended
expect(1).to.exist; // Not recommended

expect(0).to.equal(0); // Recommended
expect(0).to.exist; // Not recommended
</code></pre>
<p>Add <code>.not</code> earlier in the chain to negate <code>.exist</code>.</p>
<pre><code>expect(null).to.be.null; // Recommended
expect(null).to.not.exist; // Not recommended

expect(undefined).to.be.undefined; // Recommended
expect(undefined).to.not.exist; // Not recommended
</code></pre>
<p>A custom error message can be given as the second argument to <code>expect</code>.</p>
<pre><code>expect(null, 'nooo why fail??').to.exist;
</code></pre>
<p>The alias <code>.exists</code> can be used interchangeably with <code>.exist</code>.</p></div>
        

        


<dl class="details">

    

    

    

    

    

    

    

    

    

    

    

    
    

    

    

    
        <p class="tag-source">
            <a href="node_modules_chai_lib_chai_core_assertions.js.html" class="button">View Source</a>
            <span>
                <a href="node_modules_chai_lib_chai_core_assertions.js.html">node_modules/chai/lib/chai/core/assertions.js</a>, <a href="node_modules_chai_lib_chai_core_assertions.js.html#line802">line 802</a>
            </span>
        </p>
    
</dl>


        
    
    </div>
    
    

    

    

    

    

    

    

    

    

    
</article>

</section>







<section>

<header>
    
        <h2>BDD</h2>
        
    
</header>

<article>
    <div class="container-overview">
    
        
            <div class="description"><h3>.empty</h3>
<p>When the target is a string or array, <code>.empty</code> asserts that the target's
<code>length</code> property is strictly (<code>===</code>) equal to <code>0</code>.</p>
<pre><code>expect([]).to.be.empty;
expect('').to.be.empty;
</code></pre>
<p>When the target is a map or set, <code>.empty</code> asserts that the target's <code>size</code>
property is strictly equal to <code>0</code>.</p>
<pre><code>expect(new Set()).to.be.empty;
expect(new Map()).to.be.empty;
</code></pre>
<p>When the target is a non-function object, <code>.empty</code> asserts that the target
doesn't have any own enumerable properties. Properties with Symbol-based
keys are excluded from the count.</p>
<pre><code>expect({}).to.be.empty;
</code></pre>
<p>Because <code>.empty</code> does different things based on the target's type, it's
important to check the target's type before using <code>.empty</code>. See the <code>.a</code>
doc for info on testing a target's type.</p>
<pre><code>expect([]).to.be.an('array').that.is.empty;
</code></pre>
<p>Add <code>.not</code> earlier in the chain to negate <code>.empty</code>. However, it's often
best to assert that the target contains its expected number of values,
rather than asserting that it's not empty.</p>
<pre><code>expect([1, 2, 3]).to.have.lengthOf(3); // Recommended
expect([1, 2, 3]).to.not.be.empty; // Not recommended

expect(new Set([1, 2, 3])).to.have.property('size', 3); // Recommended
expect(new Set([1, 2, 3])).to.not.be.empty; // Not recommended

expect(Object.keys({a: 1})).to.have.lengthOf(1); // Recommended
expect({a: 1}).to.not.be.empty; // Not recommended
</code></pre>
<p>A custom error message can be given as the second argument to <code>expect</code>.</p>
<pre><code>expect([1, 2, 3], 'nooo why fail??').to.be.empty;</code></pre></div>
        

        


<dl class="details">

    

    

    

    

    

    

    

    

    

    

    

    
    

    

    

    
        <p class="tag-source">
            <a href="node_modules_chai_lib_chai_core_assertions.js.html" class="button">View Source</a>
            <span>
                <a href="node_modules_chai_lib_chai_core_assertions.js.html">node_modules/chai/lib/chai/core/assertions.js</a>, <a href="node_modules_chai_lib_chai_core_assertions.js.html#line847">line 847</a>
            </span>
        </p>
    
</dl>


        
    
    </div>
    
    

    

    

    

    

    

    

    

    

    
</article>

</section>







<section>

<header>
    
        <h2>BDD</h2>
        
    
</header>

<article>
    <div class="container-overview">
    
        
            <div class="description"><h3>.arguments</h3>
<p>Asserts that the target is an <code>arguments</code> object.</p>
<pre><code>function test () {
  expect(arguments).to.be.arguments;
}

test();
</code></pre>
<p>Add <code>.not</code> earlier in the chain to negate <code>.arguments</code>. However, it's often
best to assert which type the target is expected to be, rather than
asserting that its not an <code>arguments</code> object.</p>
<pre><code>expect('foo').to.be.a('string'); // Recommended
expect('foo').to.not.be.arguments; // Not recommended
</code></pre>
<p>A custom error message can be given as the second argument to <code>expect</code>.</p>
<pre><code>expect({}, 'nooo why fail??').to.be.arguments;
</code></pre>
<p>The alias <code>.Arguments</code> can be used interchangeably with <code>.arguments</code>.</p></div>
        

        


<dl class="details">

    

    

    

    

    

    

    

    

    

    

    

    
    

    

    

    
        <p class="tag-source">
            <a href="node_modules_chai_lib_chai_core_assertions.js.html" class="button">View Source</a>
            <span>
                <a href="node_modules_chai_lib_chai_core_assertions.js.html">node_modules/chai/lib/chai/core/assertions.js</a>, <a href="node_modules_chai_lib_chai_core_assertions.js.html#line941">line 941</a>
            </span>
        </p>
    
</dl>


        
    
    </div>
    
    

    

    

    

    

    

    

    

    

    
</article>

</section>







<section>

<header>
    
        <h2>BDD</h2>
        
    
</header>

<article>
    <div class="container-overview">
    
        
            <div class="description"><h3>.equal(val[, msg])</h3>
<p>Asserts that the target is strictly (<code>===</code>) equal to the given <code>val</code>.</p>
<pre><code>expect(1).to.equal(1);
expect('foo').to.equal('foo');
</code></pre>
<p>Add <code>.deep</code> earlier in the chain to use deep equality instead. See the
<code>deep-eql</code> project page for info on the deep equality algorithm:
https://github.com/chaijs/deep-eql.</p>
<pre><code>// Target object deeply (but not strictly) equals `{a: 1}`
expect({a: 1}).to.deep.equal({a: 1});
expect({a: 1}).to.not.equal({a: 1});

// Target array deeply (but not strictly) equals `[1, 2]`
expect([1, 2]).to.deep.equal([1, 2]);
expect([1, 2]).to.not.equal([1, 2]);
</code></pre>
<p>Add <code>.not</code> earlier in the chain to negate <code>.equal</code>. However, it's often
best to assert that the target is equal to its expected value, rather than
not equal to one of countless unexpected values.</p>
<pre><code>expect(1).to.equal(1); // Recommended
expect(1).to.not.equal(2); // Not recommended
</code></pre>
<p><code>.equal</code> accepts an optional <code>msg</code> argument which is a custom error message
to show when the assertion fails. The message can also be given as the
second argument to <code>expect</code>.</p>
<pre><code>expect(1).to.equal(2, 'nooo why fail??');
expect(1, 'nooo why fail??').to.equal(2);
</code></pre>
<p>The aliases <code>.equals</code> and <code>eq</code> can be used interchangeably with <code>.equal</code>.</p></div>
        

        


<dl class="details">

    

    

    

    

    

    

    

    

    

    

    

    
    

    

    

    
        <p class="tag-source">
            <a href="node_modules_chai_lib_chai_core_assertions.js.html" class="button">View Source</a>
            <span>
                <a href="node_modules_chai_lib_chai_core_assertions.js.html">node_modules/chai/lib/chai/core/assertions.js</a>, <a href="node_modules_chai_lib_chai_core_assertions.js.html#line984">line 984</a>
            </span>
        </p>
    
</dl>


        
    
    </div>
    
    

    

    

    

    

    

    

    

    

    
</article>

</section>







<section>

<header>
    
        <h2>BDD</h2>
        
    
</header>

<article>
    <div class="container-overview">
    
        
            <div class="description"><h3>.eql(obj[, msg])</h3>
<p>Asserts that the target is deeply equal to the given <code>obj</code>. See the
<code>deep-eql</code> project page for info on the deep equality algorithm:
https://github.com/chaijs/deep-eql.</p>
<pre><code>// Target object is deeply (but not strictly) equal to {a: 1}
expect({a: 1}).to.eql({a: 1}).but.not.equal({a: 1});

// Target array is deeply (but not strictly) equal to [1, 2]
expect([1, 2]).to.eql([1, 2]).but.not.equal([1, 2]);
</code></pre>
<p>Add <code>.not</code> earlier in the chain to negate <code>.eql</code>. However, it's often best
to assert that the target is deeply equal to its expected value, rather
than not deeply equal to one of countless unexpected values.</p>
<pre><code>expect({a: 1}).to.eql({a: 1}); // Recommended
expect({a: 1}).to.not.eql({b: 2}); // Not recommended
</code></pre>
<p><code>.eql</code> accepts an optional <code>msg</code> argument which is a custom error message
to show when the assertion fails. The message can also be given as the
second argument to <code>expect</code>.</p>
<pre><code>expect({a: 1}).to.eql({b: 2}, 'nooo why fail??');
expect({a: 1}, 'nooo why fail??').to.eql({b: 2});
</code></pre>
<p>The alias <code>.eqls</code> can be used interchangeably with <code>.eql</code>.</p>
<p>The <code>.deep.equal</code> assertion is almost identical to <code>.eql</code> but with one
difference: <code>.deep.equal</code> causes deep equality comparisons to also be used
for any other assertions that follow in the chain.</p></div>
        

        


<dl class="details">

    

    

    

    

    

    

    

    

    

    

    

    
    

    

    

    
        <p class="tag-source">
            <a href="node_modules_chai_lib_chai_core_assertions.js.html" class="button">View Source</a>
            <span>
                <a href="node_modules_chai_lib_chai_core_assertions.js.html">node_modules/chai/lib/chai/core/assertions.js</a>, <a href="node_modules_chai_lib_chai_core_assertions.js.html#line1053">line 1053</a>
            </span>
        </p>
    
</dl>


        
    
    </div>
    
    

    

    

    

    

    

    

    

    

    
</article>

</section>







<section>

<header>
    
        <h2>BDD</h2>
        
    
</header>

<article>
    <div class="container-overview">
    
        
            <div class="description"><h3>.above(n[, msg])</h3>
<p>Asserts that the target is a number or a date greater than the given number or date <code>n</code> respectively.
However, it's often best to assert that the target is equal to its expected
value.</p>
<pre><code>expect(2).to.equal(2); // Recommended
expect(2).to.be.above(1); // Not recommended
</code></pre>
<p>Add <code>.lengthOf</code> earlier in the chain to assert that the target's <code>length</code>
or <code>size</code> is greater than the given number <code>n</code>.</p>
<pre><code>expect('foo').to.have.lengthOf(3); // Recommended
expect('foo').to.have.lengthOf.above(2); // Not recommended

expect([1, 2, 3]).to.have.lengthOf(3); // Recommended
expect([1, 2, 3]).to.have.lengthOf.above(2); // Not recommended
</code></pre>
<p>Add <code>.not</code> earlier in the chain to negate <code>.above</code>.</p>
<pre><code>expect(2).to.equal(2); // Recommended
expect(1).to.not.be.above(2); // Not recommended
</code></pre>
<p><code>.above</code> accepts an optional <code>msg</code> argument which is a custom error message
to show when the assertion fails. The message can also be given as the
second argument to <code>expect</code>.</p>
<pre><code>expect(1).to.be.above(2, 'nooo why fail??');
expect(1, 'nooo why fail??').to.be.above(2);
</code></pre>
<p>The aliases <code>.gt</code> and <code>.greaterThan</code> can be used interchangeably with
<code>.above</code>.</p></div>
        

        


<dl class="details">

    

    

    

    

    

    

    

    

    

    

    

    
    

    

    

    
        <p class="tag-source">
            <a href="node_modules_chai_lib_chai_core_assertions.js.html" class="button">View Source</a>
            <span>
                <a href="node_modules_chai_lib_chai_core_assertions.js.html">node_modules/chai/lib/chai/core/assertions.js</a>, <a href="node_modules_chai_lib_chai_core_assertions.js.html#line1109">line 1109</a>
            </span>
        </p>
    
</dl>


        
    
    </div>
    
    

    

    

    

    

    

    

    

    

    
</article>

</section>







<section>

<header>
    
        <h2>BDD</h2>
        
    
</header>

<article>
    <div class="container-overview">
    
        
            <div class="description"><h3>.least(n[, msg])</h3>
<p>Asserts that the target is a number or a date greater than or equal to the given
number or date <code>n</code> respectively. However, it's often best to assert that the target is equal to
its expected value.</p>
<pre><code>expect(2).to.equal(2); // Recommended
expect(2).to.be.at.least(1); // Not recommended
expect(2).to.be.at.least(2); // Not recommended
</code></pre>
<p>Add <code>.lengthOf</code> earlier in the chain to assert that the target's <code>length</code>
or <code>size</code> is greater than or equal to the given number <code>n</code>.</p>
<pre><code>expect('foo').to.have.lengthOf(3); // Recommended
expect('foo').to.have.lengthOf.at.least(2); // Not recommended

expect([1, 2, 3]).to.have.lengthOf(3); // Recommended
expect([1, 2, 3]).to.have.lengthOf.at.least(2); // Not recommended
</code></pre>
<p>Add <code>.not</code> earlier in the chain to negate <code>.least</code>.</p>
<pre><code>expect(1).to.equal(1); // Recommended
expect(1).to.not.be.at.least(2); // Not recommended
</code></pre>
<p><code>.least</code> accepts an optional <code>msg</code> argument which is a custom error message
to show when the assertion fails. The message can also be given as the
second argument to <code>expect</code>.</p>
<pre><code>expect(1).to.be.at.least(2, 'nooo why fail??');
expect(1, 'nooo why fail??').to.be.at.least(2);
</code></pre>
<p>The aliases <code>.gte</code> and <code>.greaterThanOrEqual</code> can be used interchangeably with
<code>.least</code>.</p></div>
        

        


<dl class="details">

    

    

    

    

    

    

    

    

    

    

    

    
    

    

    

    
        <p class="tag-source">
            <a href="node_modules_chai_lib_chai_core_assertions.js.html" class="button">View Source</a>
            <span>
                <a href="node_modules_chai_lib_chai_core_assertions.js.html">node_modules/chai/lib/chai/core/assertions.js</a>, <a href="node_modules_chai_lib_chai_core_assertions.js.html#line1213">line 1213</a>
            </span>
        </p>
    
</dl>


        
    
    </div>
    
    

    

    

    

    

    

    

    

    

    
</article>

</section>







<section>

<header>
    
        <h2>BDD</h2>
        
    
</header>

<article>
    <div class="container-overview">
    
        
            <div class="description"><h3>.below(n[, msg])</h3>
<p>Asserts that the target is a number or a date less than the given number or date <code>n</code> respectively.
However, it's often best to assert that the target is equal to its expected
value.</p>
<pre><code>expect(1).to.equal(1); // Recommended
expect(1).to.be.below(2); // Not recommended
</code></pre>
<p>Add <code>.lengthOf</code> earlier in the chain to assert that the target's <code>length</code>
or <code>size</code> is less than the given number <code>n</code>.</p>
<pre><code>expect('foo').to.have.lengthOf(3); // Recommended
expect('foo').to.have.lengthOf.below(4); // Not recommended

expect([1, 2, 3]).to.have.length(3); // Recommended
expect([1, 2, 3]).to.have.lengthOf.below(4); // Not recommended
</code></pre>
<p>Add <code>.not</code> earlier in the chain to negate <code>.below</code>.</p>
<pre><code>expect(2).to.equal(2); // Recommended
expect(2).to.not.be.below(1); // Not recommended
</code></pre>
<p><code>.below</code> accepts an optional <code>msg</code> argument which is a custom error message
to show when the assertion fails. The message can also be given as the
second argument to <code>expect</code>.</p>
<pre><code>expect(2).to.be.below(1, 'nooo why fail??');
expect(2, 'nooo why fail??').to.be.below(1);
</code></pre>
<p>The aliases <code>.lt</code> and <code>.lessThan</code> can be used interchangeably with
<code>.below</code>.</p></div>
        

        


<dl class="details">

    

    

    

    

    

    

    

    

    

    

    

    
    

    

    

    
        <p class="tag-source">
            <a href="node_modules_chai_lib_chai_core_assertions.js.html" class="button">View Source</a>
            <span>
                <a href="node_modules_chai_lib_chai_core_assertions.js.html">node_modules/chai/lib/chai/core/assertions.js</a>, <a href="node_modules_chai_lib_chai_core_assertions.js.html#line1318">line 1318</a>
            </span>
        </p>
    
</dl>


        
    
    </div>
    
    

    

    

    

    

    

    

    

    

    
</article>

</section>







<section>

<header>
    
        <h2>BDD</h2>
        
    
</header>

<article>
    <div class="container-overview">
    
        
            <div class="description"><h3>.most(n[, msg])</h3>
<p>Asserts that the target is a number or a date less than or equal to the given number
or date <code>n</code> respectively. However, it's often best to assert that the target is equal to its
expected value.</p>
<pre><code>expect(1).to.equal(1); // Recommended
expect(1).to.be.at.most(2); // Not recommended
expect(1).to.be.at.most(1); // Not recommended
</code></pre>
<p>Add <code>.lengthOf</code> earlier in the chain to assert that the target's <code>length</code>
or <code>size</code> is less than or equal to the given number <code>n</code>.</p>
<pre><code>expect('foo').to.have.lengthOf(3); // Recommended
expect('foo').to.have.lengthOf.at.most(4); // Not recommended

expect([1, 2, 3]).to.have.lengthOf(3); // Recommended
expect([1, 2, 3]).to.have.lengthOf.at.most(4); // Not recommended
</code></pre>
<p>Add <code>.not</code> earlier in the chain to negate <code>.most</code>.</p>
<pre><code>expect(2).to.equal(2); // Recommended
expect(2).to.not.be.at.most(1); // Not recommended
</code></pre>
<p><code>.most</code> accepts an optional <code>msg</code> argument which is a custom error message
to show when the assertion fails. The message can also be given as the
second argument to <code>expect</code>.</p>
<pre><code>expect(2).to.be.at.most(1, 'nooo why fail??');
expect(2, 'nooo why fail??').to.be.at.most(1);
</code></pre>
<p>The aliases <code>.lte</code> and <code>.lessThanOrEqual</code> can be used interchangeably with
<code>.most</code>.</p></div>
        

        


<dl class="details">

    

    

    

    

    

    

    

    

    

    

    

    
    

    

    

    
        <p class="tag-source">
            <a href="node_modules_chai_lib_chai_core_assertions.js.html" class="button">View Source</a>
            <span>
                <a href="node_modules_chai_lib_chai_core_assertions.js.html">node_modules/chai/lib/chai/core/assertions.js</a>, <a href="node_modules_chai_lib_chai_core_assertions.js.html#line1422">line 1422</a>
            </span>
        </p>
    
</dl>


        
    
    </div>
    
    

    

    

    

    

    

    

    

    

    
</article>

</section>







<section>

<header>
    
        <h2>BDD</h2>
        
    
</header>

<article>
    <div class="container-overview">
    
        
            <div class="description"><h3>.within(start, finish[, msg])</h3>
<p>Asserts that the target is a number or a date greater than or equal to the given
number or date <code>start</code>, and less than or equal to the given number or date <code>finish</code> respectively.
However, it's often best to assert that the target is equal to its expected
value.</p>
<pre><code>expect(2).to.equal(2); // Recommended
expect(2).to.be.within(1, 3); // Not recommended
expect(2).to.be.within(2, 3); // Not recommended
expect(2).to.be.within(1, 2); // Not recommended
</code></pre>
<p>Add <code>.lengthOf</code> earlier in the chain to assert that the target's <code>length</code>
or <code>size</code> is greater than or equal to the given number <code>start</code>, and less
than or equal to the given number <code>finish</code>.</p>
<pre><code>expect('foo').to.have.lengthOf(3); // Recommended
expect('foo').to.have.lengthOf.within(2, 4); // Not recommended

expect([1, 2, 3]).to.have.lengthOf(3); // Recommended
expect([1, 2, 3]).to.have.lengthOf.within(2, 4); // Not recommended
</code></pre>
<p>Add <code>.not</code> earlier in the chain to negate <code>.within</code>.</p>
<pre><code>expect(1).to.equal(1); // Recommended
expect(1).to.not.be.within(2, 4); // Not recommended
</code></pre>
<p><code>.within</code> accepts an optional <code>msg</code> argument which is a custom error
message to show when the assertion fails. The message can also be given as
the second argument to <code>expect</code>.</p>
<pre><code>expect(4).to.be.within(1, 3, 'nooo why fail??');
expect(4, 'nooo why fail??').to.be.within(1, 3);</code></pre></div>
        

        


<dl class="details">

    

    

    

    

    

    

    

    

    

    

    

    
    

    

    

    
        <p class="tag-source">
            <a href="node_modules_chai_lib_chai_core_assertions.js.html" class="button">View Source</a>
            <span>
                <a href="node_modules_chai_lib_chai_core_assertions.js.html">node_modules/chai/lib/chai/core/assertions.js</a>, <a href="node_modules_chai_lib_chai_core_assertions.js.html#line1527">line 1527</a>
            </span>
        </p>
    
</dl>


        
    
    </div>
    
    

    

    

    

    

    

    

    

    

    
</article>

</section>







<section>

<header>
    
        <h2>BDD</h2>
        
    
</header>

<article>
    <div class="container-overview">
    
        
            <div class="description"><h3>.instanceof(constructor[, msg])</h3>
<p>Asserts that the target is an instance of the given <code>constructor</code>.</p>
<pre><code>function Cat () { }

expect(new Cat()).to.be.an.instanceof(Cat);
expect([1, 2]).to.be.an.instanceof(Array);
</code></pre>
<p>Add <code>.not</code> earlier in the chain to negate <code>.instanceof</code>.</p>
<pre><code>expect({a: 1}).to.not.be.an.instanceof(Array);
</code></pre>
<p><code>.instanceof</code> accepts an optional <code>msg</code> argument which is a custom error
message to show when the assertion fails. The message can also be given as
the second argument to <code>expect</code>.</p>
<pre><code>expect(1).to.be.an.instanceof(Array, 'nooo why fail??');
expect(1, 'nooo why fail??').to.be.an.instanceof(Array);
</code></pre>
<p>Due to limitations in ES5, <code>.instanceof</code> may not always work as expected
when using a transpiler such as Babel or TypeScript. In particular, it may
produce unexpected results when subclassing built-in object such as
<code>Array</code>, <code>Error</code>, and <code>Map</code>. See your transpiler's docs for details:</p>
<ul>
<li>(<a href="https://babeljs.io/docs/usage/caveats/#classes">Babel</a>)</li>
<li>(<a href="https://github.com/Microsoft/TypeScript/wiki/Breaking-Changes#extending-built-ins-like-error-array-and-map-may-no-longer-work">TypeScript</a>)</li>
</ul>
<p>The alias <code>.instanceOf</code> can be used interchangeably with <code>.instanceof</code>.</p></div>
        

        


<dl class="details">

    

    

    

    

    

    

    

    

    

    

    

    
    

    

    

    
        <p class="tag-source">
            <a href="node_modules_chai_lib_chai_core_assertions.js.html" class="button">View Source</a>
            <span>
                <a href="node_modules_chai_lib_chai_core_assertions.js.html">node_modules/chai/lib/chai/core/assertions.js</a>, <a href="node_modules_chai_lib_chai_core_assertions.js.html#line1628">line 1628</a>
            </span>
        </p>
    
</dl>


        
    
    </div>
    
    

    

    

    

    

    

    

    

    

    
</article>

</section>







<section>

<header>
    
        <h2>BDD</h2>
        
    
</header>

<article>
    <div class="container-overview">
    
        
            <div class="description"><h3>.property(name[, val[, msg]])</h3>
<p>Asserts that the target has a property with the given key <code>name</code>.</p>
<pre><code>expect({a: 1}).to.have.property('a');
</code></pre>
<p>When <code>val</code> is provided, <code>.property</code> also asserts that the property's value
is equal to the given <code>val</code>.</p>
<pre><code>expect({a: 1}).to.have.property('a', 1);
</code></pre>
<p>By default, strict (<code>===</code>) equality is used. Add <code>.deep</code> earlier in the
chain to use deep equality instead. See the <code>deep-eql</code> project page for
info on the deep equality algorithm: https://github.com/chaijs/deep-eql.</p>
<pre><code>// Target object deeply (but not strictly) has property `x: {a: 1}`
expect({x: {a: 1}}).to.have.deep.property('x', {a: 1});
expect({x: {a: 1}}).to.not.have.property('x', {a: 1});
</code></pre>
<p>The target's enumerable and non-enumerable properties are always included
in the search. By default, both own and inherited properties are included.
Add <code>.own</code> earlier in the chain to exclude inherited properties from the
search.</p>
<pre><code>Object.prototype.b = 2;

expect({a: 1}).to.have.own.property('a');
expect({a: 1}).to.have.own.property('a', 1);
expect({a: 1}).to.have.property('b');
expect({a: 1}).to.not.have.own.property('b');
</code></pre>
<p><code>.deep</code> and <code>.own</code> can be combined.</p>
<pre><code>expect({x: {a: 1}}).to.have.deep.own.property('x', {a: 1});
</code></pre>
<p>Add <code>.nested</code> earlier in the chain to enable dot- and bracket-notation when
referencing nested properties.</p>
<pre><code>expect({a: {b: ['x', 'y']}}).to.have.nested.property('a.b[1]');
expect({a: {b: ['x', 'y']}}).to.have.nested.property('a.b[1]', 'y');
</code></pre>
<p>If <code>.</code> or <code>[]</code> are part of an actual property name, they can be escaped by
adding two backslashes before them.</p>
<pre><code>expect({'.a': {'[b]': 'x'}}).to.have.nested.property('\\.a.\\[b\\]');
</code></pre>
<p><code>.deep</code> and <code>.nested</code> can be combined.</p>
<pre><code>expect({a: {b: [{c: 3}]}})
  .to.have.deep.nested.property('a.b[0]', {c: 3});
</code></pre>
<p><code>.own</code> and <code>.nested</code> cannot be combined.</p>
<p>Add <code>.not</code> earlier in the chain to negate <code>.property</code>.</p>
<pre><code>expect({a: 1}).to.not.have.property('b');
</code></pre>
<p>However, it's dangerous to negate <code>.property</code> when providing <code>val</code>. The
problem is that it creates uncertain expectations by asserting that the
target either doesn't have a property with the given key <code>name</code>, or that it
does have a property with the given key <code>name</code> but its value isn't equal to
the given <code>val</code>. It's often best to identify the exact output that's
expected, and then write an assertion that only accepts that exact output.</p>
<p>When the target isn't expected to have a property with the given key
<code>name</code>, it's often best to assert exactly that.</p>
<pre><code>expect({b: 2}).to.not.have.property('a'); // Recommended
expect({b: 2}).to.not.have.property('a', 1); // Not recommended
</code></pre>
<p>When the target is expected to have a property with the given key <code>name</code>,
it's often best to assert that the property has its expected value, rather
than asserting that it doesn't have one of many unexpected values.</p>
<pre><code>expect({a: 3}).to.have.property('a', 3); // Recommended
expect({a: 3}).to.not.have.property('a', 1); // Not recommended
</code></pre>
<p><code>.property</code> changes the target of any assertions that follow in the chain
to be the value of the property from the original target object.</p>
<pre><code>expect({a: 1}).to.have.property('a').that.is.a('number');
</code></pre>
<p><code>.property</code> accepts an optional <code>msg</code> argument which is a custom error
message to show when the assertion fails. The message can also be given as
the second argument to <code>expect</code>. When not providing <code>val</code>, only use the
second form.</p>
<pre><code>// Recommended
expect({a: 1}).to.have.property('a', 2, 'nooo why fail??');
expect({a: 1}, 'nooo why fail??').to.have.property('a', 2);
expect({a: 1}, 'nooo why fail??').to.have.property('b');

// Not recommended
expect({a: 1}).to.have.property('b', undefined, 'nooo why fail??');
</code></pre>
<p>The above assertion isn't the same thing as not providing <code>val</code>. Instead,
it's asserting that the target object has a <code>b</code> property that's equal to
<code>undefined</code>.</p>
<p>The assertions <code>.ownProperty</code> and <code>.haveOwnProperty</code> can be used
interchangeably with <code>.own.property</code>.</p></div>
        

        


<dl class="details">

    

    

    

    

    

    

    

    

    

    

    

    
    

    

    

    
        <p class="tag-source">
            <a href="node_modules_chai_lib_chai_core_assertions.js.html" class="button">View Source</a>
            <span>
                <a href="node_modules_chai_lib_chai_core_assertions.js.html">node_modules/chai/lib/chai/core/assertions.js</a>, <a href="node_modules_chai_lib_chai_core_assertions.js.html#line1704">line 1704</a>
            </span>
        </p>
    
</dl>


        
    
    </div>
    
    

    

    

    

    

    

    

    

    

    
</article>

</section>







<section>

<header>
    
        <h2>BDD</h2>
        
    
</header>

<article>
    <div class="container-overview">
    
        
            <div class="description"><h3>.ownPropertyDescriptor(name[, descriptor[, msg]])</h3>
<p>Asserts that the target has its own property descriptor with the given key
<code>name</code>. Enumerable and non-enumerable properties are included in the
search.</p>
<pre><code>expect({a: 1}).to.have.ownPropertyDescriptor('a');
</code></pre>
<p>When <code>descriptor</code> is provided, <code>.ownPropertyDescriptor</code> also asserts that
the property's descriptor is deeply equal to the given <code>descriptor</code>. See
the <code>deep-eql</code> project page for info on the deep equality algorithm:
https://github.com/chaijs/deep-eql.</p>
<pre><code>expect({a: 1}).to.have.ownPropertyDescriptor('a', {
  configurable: true,
  enumerable: true,
  writable: true,
  value: 1,
});
</code></pre>
<p>Add <code>.not</code> earlier in the chain to negate <code>.ownPropertyDescriptor</code>.</p>
<pre><code>expect({a: 1}).to.not.have.ownPropertyDescriptor('b');
</code></pre>
<p>However, it's dangerous to negate <code>.ownPropertyDescriptor</code> when providing
a <code>descriptor</code>. The problem is that it creates uncertain expectations by
asserting that the target either doesn't have a property descriptor with
the given key <code>name</code>, or that it does have a property descriptor with the
given key <code>name</code> but its not deeply equal to the given <code>descriptor</code>. It's
often best to identify the exact output that's expected, and then write an
assertion that only accepts that exact output.</p>
<p>When the target isn't expected to have a property descriptor with the given
key <code>name</code>, it's often best to assert exactly that.</p>
<pre><code>// Recommended
expect({b: 2}).to.not.have.ownPropertyDescriptor('a');

// Not recommended
expect({b: 2}).to.not.have.ownPropertyDescriptor('a', {
  configurable: true,
  enumerable: true,
  writable: true,
  value: 1,
});
</code></pre>
<p>When the target is expected to have a property descriptor with the given
key <code>name</code>, it's often best to assert that the property has its expected
descriptor, rather than asserting that it doesn't have one of many
unexpected descriptors.</p>
<pre><code>// Recommended
expect({a: 3}).to.have.ownPropertyDescriptor('a', {
  configurable: true,
  enumerable: true,
  writable: true,
  value: 3,
});

// Not recommended
expect({a: 3}).to.not.have.ownPropertyDescriptor('a', {
  configurable: true,
  enumerable: true,
  writable: true,
  value: 1,
});
</code></pre>
<p><code>.ownPropertyDescriptor</code> changes the target of any assertions that follow
in the chain to be the value of the property descriptor from the original
target object.</p>
<pre><code>expect({a: 1}).to.have.ownPropertyDescriptor('a')
  .that.has.property('enumerable', true);
</code></pre>
<p><code>.ownPropertyDescriptor</code> accepts an optional <code>msg</code> argument which is a
custom error message to show when the assertion fails. The message can also
be given as the second argument to <code>expect</code>. When not providing
<code>descriptor</code>, only use the second form.</p>
<pre><code>// Recommended
expect({a: 1}).to.have.ownPropertyDescriptor('a', {
  configurable: true,
  enumerable: true,
  writable: true,
  value: 2,
}, 'nooo why fail??');

// Recommended
expect({a: 1}, 'nooo why fail??').to.have.ownPropertyDescriptor('a', {
  configurable: true,
  enumerable: true,
  writable: true,
  value: 2,
});

// Recommended
expect({a: 1}, 'nooo why fail??').to.have.ownPropertyDescriptor('b');

// Not recommended
expect({a: 1})
  .to.have.ownPropertyDescriptor('b', undefined, 'nooo why fail??');
</code></pre>
<p>The above assertion isn't the same thing as not providing <code>descriptor</code>.
Instead, it's asserting that the target object has a <code>b</code> property
descriptor that's deeply equal to <code>undefined</code>.</p>
<p>The alias <code>.haveOwnPropertyDescriptor</code> can be used interchangeably with
<code>.ownPropertyDescriptor</code>.</p></div>
        

        


<dl class="details">

    

    

    

    

    

    

    

    

    

    

    

    
    

    

    

    
        <p class="tag-source">
            <a href="node_modules_chai_lib_chai_core_assertions.js.html" class="button">View Source</a>
            <span>
                <a href="node_modules_chai_lib_chai_core_assertions.js.html">node_modules/chai/lib/chai/core/assertions.js</a>, <a href="node_modules_chai_lib_chai_core_assertions.js.html#line1913">line 1913</a>
            </span>
        </p>
    
</dl>


        
    
    </div>
    
    

    

    

    

    

    

    

    

    

    
</article>

</section>







<section>

<header>
    
        <h2>BDD</h2>
        
    
</header>

<article>
    <div class="container-overview">
    
        
            <div class="description"><h3>.lengthOf(n[, msg])</h3>
<p>Asserts that the target's <code>length</code> or <code>size</code> is equal to the given number
<code>n</code>.</p>
<pre><code>expect([1, 2, 3]).to.have.lengthOf(3);
expect('foo').to.have.lengthOf(3);
expect(new Set([1, 2, 3])).to.have.lengthOf(3);
expect(new Map([['a', 1], ['b', 2], ['c', 3]])).to.have.lengthOf(3);
</code></pre>
<p>Add <code>.not</code> earlier in the chain to negate <code>.lengthOf</code>. However, it's often
best to assert that the target's <code>length</code> property is equal to its expected
value, rather than not equal to one of many unexpected values.</p>
<pre><code>expect('foo').to.have.lengthOf(3); // Recommended
expect('foo').to.not.have.lengthOf(4); // Not recommended
</code></pre>
<p><code>.lengthOf</code> accepts an optional <code>msg</code> argument which is a custom error
message to show when the assertion fails. The message can also be given as
the second argument to <code>expect</code>.</p>
<pre><code>expect([1, 2, 3]).to.have.lengthOf(2, 'nooo why fail??');
expect([1, 2, 3], 'nooo why fail??').to.have.lengthOf(2);
</code></pre>
<p><code>.lengthOf</code> can also be used as a language chain, causing all <code>.above</code>,
<code>.below</code>, <code>.least</code>, <code>.most</code>, and <code>.within</code> assertions that follow in the
chain to use the target's <code>length</code> property as the target. However, it's
often best to assert that the target's <code>length</code> property is equal to its
expected length, rather than asserting that its <code>length</code> property falls
within some range of values.</p>
<pre><code>// Recommended
expect([1, 2, 3]).to.have.lengthOf(3);

// Not recommended
expect([1, 2, 3]).to.have.lengthOf.above(2);
expect([1, 2, 3]).to.have.lengthOf.below(4);
expect([1, 2, 3]).to.have.lengthOf.at.least(3);
expect([1, 2, 3]).to.have.lengthOf.at.most(3);
expect([1, 2, 3]).to.have.lengthOf.within(2,4);
</code></pre>
<p>Due to a compatibility issue, the alias <code>.length</code> can't be chained directly
off of an uninvoked method such as <code>.a</code>. Therefore, <code>.length</code> can't be used
interchangeably with <code>.lengthOf</code> in every situation. It's recommended to
always use <code>.lengthOf</code> instead of <code>.length</code>.</p>
<pre><code>expect([1, 2, 3]).to.have.a.length(3); // incompatible; throws error
expect([1, 2, 3]).to.have.a.lengthOf(3);  // passes as expected</code></pre></div>
        

        


<dl class="details">

    

    

    

    

    

    

    

    

    

    

    

    
    

    

    

    
        <p class="tag-source">
            <a href="node_modules_chai_lib_chai_core_assertions.js.html" class="button">View Source</a>
            <span>
                <a href="node_modules_chai_lib_chai_core_assertions.js.html">node_modules/chai/lib/chai/core/assertions.js</a>, <a href="node_modules_chai_lib_chai_core_assertions.js.html#line2062">line 2062</a>
            </span>
        </p>
    
</dl>


        
    
    </div>
    
    

    

    

    

    

    

    

    

    

    
</article>

</section>







<section>

<header>
    
        <h2>BDD</h2>
        
    
</header>

<article>
    <div class="container-overview">
    
        
            <div class="description"><h3>.match(re[, msg])</h3>
<p>Asserts that the target matches the given regular expression <code>re</code>.</p>
<pre><code>expect('foobar').to.match(/^foo/);
</code></pre>
<p>Add <code>.not</code> earlier in the chain to negate <code>.match</code>.</p>
<pre><code>expect('foobar').to.not.match(/taco/);
</code></pre>
<p><code>.match</code> accepts an optional <code>msg</code> argument which is a custom error message
to show when the assertion fails. The message can also be given as the
second argument to <code>expect</code>.</p>
<pre><code>expect('foobar').to.match(/taco/, 'nooo why fail??');
expect('foobar', 'nooo why fail??').to.match(/taco/);
</code></pre>
<p>The alias <code>.matches</code> can be used interchangeably with <code>.match</code>.</p></div>
        

        


<dl class="details">

    

    

    

    

    

    

    

    

    

    

    

    
    

    

    

    
        <p class="tag-source">
            <a href="node_modules_chai_lib_chai_core_assertions.js.html" class="button">View Source</a>
            <span>
                <a href="node_modules_chai_lib_chai_core_assertions.js.html">node_modules/chai/lib/chai/core/assertions.js</a>, <a href="node_modules_chai_lib_chai_core_assertions.js.html#line2156">line 2156</a>
            </span>
        </p>
    
</dl>


        
    
    </div>
    
    

    

    

    

    

    

    

    

    

    
</article>

</section>







<section>

<header>
    
        <h2>BDD</h2>
        
    
</header>

<article>
    <div class="container-overview">
    
        
            <div class="description"><h3>.string(str[, msg])</h3>
<p>Asserts that the target string contains the given substring <code>str</code>.</p>
<pre><code>expect('foobar').to.have.string('bar');
</code></pre>
<p>Add <code>.not</code> earlier in the chain to negate <code>.string</code>.</p>
<pre><code>expect('foobar').to.not.have.string('taco');
</code></pre>
<p><code>.string</code> accepts an optional <code>msg</code> argument which is a custom error
message to show when the assertion fails. The message can also be given as
the second argument to <code>expect</code>.</p>
<pre><code>expect('foobar').to.have.string('taco', 'nooo why fail??');
expect('foobar', 'nooo why fail??').to.have.string('taco');</code></pre></div>
        

        


<dl class="details">

    

    

    

    

    

    

    

    

    

    

    

    
    

    

    

    
        <p class="tag-source">
            <a href="node_modules_chai_lib_chai_core_assertions.js.html" class="button">View Source</a>
            <span>
                <a href="node_modules_chai_lib_chai_core_assertions.js.html">node_modules/chai/lib/chai/core/assertions.js</a>, <a href="node_modules_chai_lib_chai_core_assertions.js.html#line2196">line 2196</a>
            </span>
        </p>
    
</dl>


        
    
    </div>
    
    

    

    

    

    

    

    

    

    

    
</article>

</section>







<section>

<header>
    
        <h2>BDD</h2>
        
    
</header>

<article>
    <div class="container-overview">
    
        
            <div class="description"><h3>.keys(key1[, key2[, ...]])</h3>
<p>Asserts that the target object, array, map, or set has the given keys. Only
the target's own inherited properties are included in the search.</p>
<p>When the target is an object or array, keys can be provided as one or more
string arguments, a single array argument, or a single object argument. In
the latter case, only the keys in the given object matter; the values are
ignored.</p>
<pre><code>expect({a: 1, b: 2}).to.have.all.keys('a', 'b');
expect(['x', 'y']).to.have.all.keys(0, 1);

expect({a: 1, b: 2}).to.have.all.keys(['a', 'b']);
expect(['x', 'y']).to.have.all.keys([0, 1]);

expect({a: 1, b: 2}).to.have.all.keys({a: 4, b: 5}); // ignore 4 and 5
expect(['x', 'y']).to.have.all.keys({0: 4, 1: 5}); // ignore 4 and 5
</code></pre>
<p>When the target is a map or set, each key must be provided as a separate
argument.</p>
<pre><code>expect(new Map([['a', 1], ['b', 2]])).to.have.all.keys('a', 'b');
expect(new Set(['a', 'b'])).to.have.all.keys('a', 'b');
</code></pre>
<p>Because <code>.keys</code> does different things based on the target's type, it's
important to check the target's type before using <code>.keys</code>. See the <code>.a</code> doc
for info on testing a target's type.</p>
<pre><code>expect({a: 1, b: 2}).to.be.an('object').that.has.all.keys('a', 'b');
</code></pre>
<p>By default, strict (<code>===</code>) equality is used to compare keys of maps and
sets. Add <code>.deep</code> earlier in the chain to use deep equality instead. See
the <code>deep-eql</code> project page for info on the deep equality algorithm:
https://github.com/chaijs/deep-eql.</p>
<pre><code>// Target set deeply (but not strictly) has key `{a: 1}`
expect(new Set([{a: 1}])).to.have.all.deep.keys([{a: 1}]);
expect(new Set([{a: 1}])).to.not.have.all.keys([{a: 1}]);
</code></pre>
<p>By default, the target must have all of the given keys and no more. Add
<code>.any</code> earlier in the chain to only require that the target have at least
one of the given keys. Also, add <code>.not</code> earlier in the chain to negate
<code>.keys</code>. It's often best to add <code>.any</code> when negating <code>.keys</code>, and to use
<code>.all</code> when asserting <code>.keys</code> without negation.</p>
<p>When negating <code>.keys</code>, <code>.any</code> is preferred because <code>.not.any.keys</code> asserts
exactly what's expected of the output, whereas <code>.not.all.keys</code> creates
uncertain expectations.</p>
<pre><code>// Recommended; asserts that target doesn't have any of the given keys
expect({a: 1, b: 2}).to.not.have.any.keys('c', 'd');

// Not recommended; asserts that target doesn't have all of the given
// keys but may or may not have some of them
expect({a: 1, b: 2}).to.not.have.all.keys('c', 'd');
</code></pre>
<p>When asserting <code>.keys</code> without negation, <code>.all</code> is preferred because
<code>.all.keys</code> asserts exactly what's expected of the output, whereas
<code>.any.keys</code> creates uncertain expectations.</p>
<pre><code>// Recommended; asserts that target has all the given keys
expect({a: 1, b: 2}).to.have.all.keys('a', 'b');

// Not recommended; asserts that target has at least one of the given
// keys but may or may not have more of them
expect({a: 1, b: 2}).to.have.any.keys('a', 'b');
</code></pre>
<p>Note that <code>.all</code> is used by default when neither <code>.all</code> nor <code>.any</code> appear
earlier in the chain. However, it's often best to add <code>.all</code> anyway because
it improves readability.</p>
<pre><code>// Both assertions are identical
expect({a: 1, b: 2}).to.have.all.keys('a', 'b'); // Recommended
expect({a: 1, b: 2}).to.have.keys('a', 'b'); // Not recommended
</code></pre>
<p>Add <code>.include</code> earlier in the chain to require that the target's keys be a
superset of the expected keys, rather than identical sets.</p>
<pre><code>// Target object's keys are a superset of ['a', 'b'] but not identical
expect({a: 1, b: 2, c: 3}).to.include.all.keys('a', 'b');
expect({a: 1, b: 2, c: 3}).to.not.have.all.keys('a', 'b');
</code></pre>
<p>However, if <code>.any</code> and <code>.include</code> are combined, only the <code>.any</code> takes
effect. The <code>.include</code> is ignored in this case.</p>
<pre><code>// Both assertions are identical
expect({a: 1}).to.have.any.keys('a', 'b');
expect({a: 1}).to.include.any.keys('a', 'b');
</code></pre>
<p>A custom error message can be given as the second argument to <code>expect</code>.</p>
<pre><code>expect({a: 1}, 'nooo why fail??').to.have.key('b');
</code></pre>
<p>The alias <code>.key</code> can be used interchangeably with <code>.keys</code>.</p></div>
        

        


<dl class="details">

    

    

    

    

    

    

    

    

    

    

    

    
    

    

    

    
        <p class="tag-source">
            <a href="node_modules_chai_lib_chai_core_assertions.js.html" class="button">View Source</a>
            <span>
                <a href="node_modules_chai_lib_chai_core_assertions.js.html">node_modules/chai/lib/chai/core/assertions.js</a>, <a href="node_modules_chai_lib_chai_core_assertions.js.html#line2235">line 2235</a>
            </span>
        </p>
    
</dl>


        
    
    </div>
    
    

    

    

    

    

    

    

    

    

    
</article>

</section>







<section>

<header>
    
        <h2>BDD</h2>
        
    
</header>

<article>
    <div class="container-overview">
    
        
            <div class="description"><h3>.throw([errorLike], [errMsgMatcher], [msg])</h3>
<p>When no arguments are provided, <code>.throw</code> invokes the target function and
asserts that an error is thrown.</p>
<pre><code>var badFn = function () { throw new TypeError('Illegal salmon!'); };

expect(badFn).to.throw();
</code></pre>
<p>When one argument is provided, and it's an error constructor, <code>.throw</code>
invokes the target function and asserts that an error is thrown that's an
instance of that error constructor.</p>
<pre><code>var badFn = function () { throw new TypeError('Illegal salmon!'); };

expect(badFn).to.throw(TypeError);
</code></pre>
<p>When one argument is provided, and it's an error instance, <code>.throw</code> invokes
the target function and asserts that an error is thrown that's strictly
(<code>===</code>) equal to that error instance.</p>
<pre><code>var err = new TypeError('Illegal salmon!');
var badFn = function () { throw err; };

expect(badFn).to.throw(err);
</code></pre>
<p>When one argument is provided, and it's a string, <code>.throw</code> invokes the
target function and asserts that an error is thrown with a message that
contains that string.</p>
<pre><code>var badFn = function () { throw new TypeError('Illegal salmon!'); };

expect(badFn).to.throw('salmon');
</code></pre>
<p>When one argument is provided, and it's a regular expression, <code>.throw</code>
invokes the target function and asserts that an error is thrown with a
message that matches that regular expression.</p>
<pre><code>var badFn = function () { throw new TypeError('Illegal salmon!'); };

expect(badFn).to.throw(/salmon/);
</code></pre>
<p>When two arguments are provided, and the first is an error instance or
constructor, and the second is a string or regular expression, <code>.throw</code>
invokes the function and asserts that an error is thrown that fulfills both
conditions as described above.</p>
<pre><code>var err = new TypeError('Illegal salmon!');
var badFn = function () { throw err; };

expect(badFn).to.throw(TypeError, 'salmon');
expect(badFn).to.throw(TypeError, /salmon/);
expect(badFn).to.throw(err, 'salmon');
expect(badFn).to.throw(err, /salmon/);
</code></pre>
<p>Add <code>.not</code> earlier in the chain to negate <code>.throw</code>.</p>
<pre><code>var goodFn = function () {};

expect(goodFn).to.not.throw();
</code></pre>
<p>However, it's dangerous to negate <code>.throw</code> when providing any arguments.
The problem is that it creates uncertain expectations by asserting that the
target either doesn't throw an error, or that it throws an error but of a
different type than the given type, or that it throws an error of the given
type but with a message that doesn't include the given string. It's often
best to identify the exact output that's expected, and then write an
assertion that only accepts that exact output.</p>
<p>When the target isn't expected to throw an error, it's often best to assert
exactly that.</p>
<pre><code>var goodFn = function () {};

expect(goodFn).to.not.throw(); // Recommended
expect(goodFn).to.not.throw(ReferenceError, 'x'); // Not recommended
</code></pre>
<p>When the target is expected to throw an error, it's often best to assert
that the error is of its expected type, and has a message that includes an
expected string, rather than asserting that it doesn't have one of many
unexpected types, and doesn't have a message that includes some string.</p>
<pre><code>var badFn = function () { throw new TypeError('Illegal salmon!'); };

expect(badFn).to.throw(TypeError, 'salmon'); // Recommended
expect(badFn).to.not.throw(ReferenceError, 'x'); // Not recommended
</code></pre>
<p><code>.throw</code> changes the target of any assertions that follow in the chain to
be the error object that's thrown.</p>
<pre><code>var err = new TypeError('Illegal salmon!');
err.code = 42;
var badFn = function () { throw err; };

expect(badFn).to.throw(TypeError).with.property('code', 42);
</code></pre>
<p><code>.throw</code> accepts an optional <code>msg</code> argument which is a custom error message
to show when the assertion fails. The message can also be given as the
second argument to <code>expect</code>. When not providing two arguments, always use
the second form.</p>
<pre><code>var goodFn = function () {};

expect(goodFn).to.throw(TypeError, 'x', 'nooo why fail??');
expect(goodFn, 'nooo why fail??').to.throw();
</code></pre>
<p>Due to limitations in ES5, <code>.throw</code> may not always work as expected when
using a transpiler such as Babel or TypeScript. In particular, it may
produce unexpected results when subclassing the built-in <code>Error</code> object and
then passing the subclassed constructor to <code>.throw</code>. See your transpiler's
docs for details:</p>
<ul>
<li>(<a href="https://babeljs.io/docs/usage/caveats/#classes">Babel</a>)</li>
<li>(<a href="https://github.com/Microsoft/TypeScript/wiki/Breaking-Changes#extending-built-ins-like-error-array-and-map-may-no-longer-work">TypeScript</a>)</li>
</ul>
<p>Beware of some common mistakes when using the <code>throw</code> assertion. One common
mistake is to accidentally invoke the function yourself instead of letting
the <code>throw</code> assertion invoke the function for you. For example, when
testing if a function named <code>fn</code> throws, provide <code>fn</code> instead of <code>fn()</code> as
the target for the assertion.</p>
<pre><code>expect(fn).to.throw();     // Good! Tests `fn` as desired
expect(fn()).to.throw();   // Bad! Tests result of `fn()`, not `fn`
</code></pre>
<p>If you need to assert that your function <code>fn</code> throws when passed certain
arguments, then wrap a call to <code>fn</code> inside of another function.</p>
<pre><code>expect(function () { fn(42); }).to.throw();  // Function expression
expect(() =&gt; fn(42)).to.throw();             // ES6 arrow function
</code></pre>
<p>Another common mistake is to provide an object method (or any stand-alone
function that relies on <code>this</code>) as the target of the assertion. Doing so is
problematic because the <code>this</code> context will be lost when the function is
invoked by <code>.throw</code>; there's no way for it to know what <code>this</code> is supposed
to be. There are two ways around this problem. One solution is to wrap the
method or function call inside of another function. Another solution is to
use <code>bind</code>.</p>
<pre><code>expect(function () { cat.meow(); }).to.throw();  // Function expression
expect(() =&gt; cat.meow()).to.throw();             // ES6 arrow function
expect(cat.meow.bind(cat)).to.throw();           // Bind
</code></pre>
<p>Finally, it's worth mentioning that it's a best practice in JavaScript to
only throw <code>Error</code> and derivatives of <code>Error</code> such as <code>ReferenceError</code>,
<code>TypeError</code>, and user-defined objects that extend <code>Error</code>. No other type of
value will generate a stack trace when initialized. With that said, the
<code>throw</code> assertion does technically support any type of value being thrown,
not just <code>Error</code> and its derivatives.</p>
<p>The aliases <code>.throws</code> and <code>.Throw</code> can be used interchangeably with
<code>.throw</code>.</p></div>
        

        


<dl class="details">

    

    

    

    

    

    

    

    

    

    

    

    
    

    
    <dt class="tag-see">See:</dt>
    <dd class="tag-see">
        <ul>
            <li><a href="https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Error#Error_types">https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Error#Error_types</a></li>
        </ul>
    </dd>
    

    

    
        <p class="tag-source">
            <a href="node_modules_chai_lib_chai_core_assertions.js.html" class="button">View Source</a>
            <span>
                <a href="node_modules_chai_lib_chai_core_assertions.js.html">node_modules/chai/lib/chai/core/assertions.js</a>, <a href="node_modules_chai_lib_chai_core_assertions.js.html#line2468">line 2468</a>
            </span>
        </p>
    
</dl>


        
    
    </div>
    
    

    

    

    

    

    

    

    

    

    
</article>

</section>







<section>

<header>
    
        <h2>BDD</h2>
        
    
</header>

<article>
    <div class="container-overview">
    
        
            <div class="description"><h3>.respondTo(method[, msg])</h3>
<p>When the target is a non-function object, <code>.respondTo</code> asserts that the
target has a method with the given name <code>method</code>. The method can be own or
inherited, and it can be enumerable or non-enumerable.</p>
<pre><code>function Cat () {}
Cat.prototype.meow = function () {};

expect(new Cat()).to.respondTo('meow');
</code></pre>
<p>When the target is a function, <code>.respondTo</code> asserts that the target's
<code>prototype</code> property has a method with the given name <code>method</code>. Again, the
method can be own or inherited, and it can be enumerable or non-enumerable.</p>
<pre><code>function Cat () {}
Cat.prototype.meow = function () {};

expect(Cat).to.respondTo('meow');
</code></pre>
<p>Add <code>.itself</code> earlier in the chain to force <code>.respondTo</code> to treat the
target as a non-function object, even if it's a function. Thus, it asserts
that the target has a method with the given name <code>method</code>, rather than
asserting that the target's <code>prototype</code> property has a method with the
given name <code>method</code>.</p>
<pre><code>function Cat () {}
Cat.prototype.meow = function () {};
Cat.hiss = function () {};

expect(Cat).itself.to.respondTo('hiss').but.not.respondTo('meow');
</code></pre>
<p>When not adding <code>.itself</code>, it's important to check the target's type before
using <code>.respondTo</code>. See the <code>.a</code> doc for info on checking a target's type.</p>
<pre><code>function Cat () {}
Cat.prototype.meow = function () {};

expect(new Cat()).to.be.an('object').that.respondsTo('meow');
</code></pre>
<p>Add <code>.not</code> earlier in the chain to negate <code>.respondTo</code>.</p>
<pre><code>function Dog () {}
Dog.prototype.bark = function () {};

expect(new Dog()).to.not.respondTo('meow');
</code></pre>
<p><code>.respondTo</code> accepts an optional <code>msg</code> argument which is a custom error
message to show when the assertion fails. The message can also be given as
the second argument to <code>expect</code>.</p>
<pre><code>expect({}).to.respondTo('meow', 'nooo why fail??');
expect({}, 'nooo why fail??').to.respondTo('meow');
</code></pre>
<p>The alias <code>.respondsTo</code> can be used interchangeably with <code>.respondTo</code>.</p></div>
        

        


<dl class="details">

    

    

    

    

    

    

    

    

    

    

    

    
    

    

    

    
        <p class="tag-source">
            <a href="node_modules_chai_lib_chai_core_assertions.js.html" class="button">View Source</a>
            <span>
                <a href="node_modules_chai_lib_chai_core_assertions.js.html">node_modules/chai/lib/chai/core/assertions.js</a>, <a href="node_modules_chai_lib_chai_core_assertions.js.html#line2763">line 2763</a>
            </span>
        </p>
    
</dl>


        
    
    </div>
    
    

    

    

    

    

    

    

    

    

    
</article>

</section>







<section>

<header>
    
        <h2>BDD</h2>
        
    
</header>

<article>
    <div class="container-overview">
    
        
            <div class="description"><h3>.itself</h3>
<p>Forces all <code>.respondTo</code> assertions that follow in the chain to behave as if
the target is a non-function object, even if it's a function. Thus, it
causes <code>.respondTo</code> to assert that the target has a method with the given
name, rather than asserting that the target's <code>prototype</code> property has a
method with the given name.</p>
<pre><code>function Cat () {}
Cat.prototype.meow = function () {};
Cat.hiss = function () {};

expect(Cat).itself.to.respondTo('hiss').but.not.respondTo('meow');</code></pre></div>
        

        


<dl class="details">

    

    

    

    

    

    

    

    

    

    

    

    
    

    

    

    
        <p class="tag-source">
            <a href="node_modules_chai_lib_chai_core_assertions.js.html" class="button">View Source</a>
            <span>
                <a href="node_modules_chai_lib_chai_core_assertions.js.html">node_modules/chai/lib/chai/core/assertions.js</a>, <a href="node_modules_chai_lib_chai_core_assertions.js.html#line2846">line 2846</a>
            </span>
        </p>
    
</dl>


        
    
    </div>
    
    

    

    

    

    

    

    

    

    

    
</article>

</section>







<section>

<header>
    
        <h2>BDD</h2>
        
    
</header>

<article>
    <div class="container-overview">
    
        
            <div class="description"><h3>.satisfy(matcher[, msg])</h3>
<p>Invokes the given <code>matcher</code> function with the target being passed as the
first argument, and asserts that the value returned is truthy.</p>
<pre><code>expect(1).to.satisfy(function(num) {
  return num &gt; 0;
});
</code></pre>
<p>Add <code>.not</code> earlier in the chain to negate <code>.satisfy</code>.</p>
<pre><code>expect(1).to.not.satisfy(function(num) {
  return num &gt; 2;
});
</code></pre>
<p><code>.satisfy</code> accepts an optional <code>msg</code> argument which is a custom error
message to show when the assertion fails. The message can also be given as
the second argument to <code>expect</code>.</p>
<pre><code>expect(1).to.satisfy(function(num) {
  return num &gt; 2;
}, 'nooo why fail??');

expect(1, 'nooo why fail??').to.satisfy(function(num) {
  return num &gt; 2;
});
</code></pre>
<p>The alias <code>.satisfies</code> can be used interchangeably with <code>.satisfy</code>.</p></div>
        

        


<dl class="details">

    

    

    

    

    

    

    

    

    

    

    

    
    

    

    

    
        <p class="tag-source">
            <a href="node_modules_chai_lib_chai_core_assertions.js.html" class="button">View Source</a>
            <span>
                <a href="node_modules_chai_lib_chai_core_assertions.js.html">node_modules/chai/lib/chai/core/assertions.js</a>, <a href="node_modules_chai_lib_chai_core_assertions.js.html#line2870">line 2870</a>
            </span>
        </p>
    
</dl>


        
    
    </div>
    
    

    

    

    

    

    

    

    

    

    
</article>

</section>







<section>

<header>
    
        <h2>BDD</h2>
        
    
</header>

<article>
    <div class="container-overview">
    
        
            <div class="description"><h3>.closeTo(expected, delta[, msg])</h3>
<p>Asserts that the target is a number that's within a given +/- <code>delta</code> range
of the given number <code>expected</code>. However, it's often best to assert that the
target is equal to its expected value.</p>
<pre><code>// Recommended
expect(1.5).to.equal(1.5);

// Not recommended
expect(1.5).to.be.closeTo(1, 0.5);
expect(1.5).to.be.closeTo(2, 0.5);
expect(1.5).to.be.closeTo(1, 1);
</code></pre>
<p>Add <code>.not</code> earlier in the chain to negate <code>.closeTo</code>.</p>
<pre><code>expect(1.5).to.equal(1.5); // Recommended
expect(1.5).to.not.be.closeTo(3, 1); // Not recommended
</code></pre>
<p><code>.closeTo</code> accepts an optional <code>msg</code> argument which is a custom error
message to show when the assertion fails. The message can also be given as
the second argument to <code>expect</code>.</p>
<pre><code>expect(1.5).to.be.closeTo(3, 1, 'nooo why fail??');
expect(1.5, 'nooo why fail??').to.be.closeTo(3, 1);
</code></pre>
<p>The alias <code>.approximately</code> can be used interchangeably with <code>.closeTo</code>.</p></div>
        

        


<dl class="details">

    

    

    

    

    

    

    

    

    

    

    

    
    

    

    

    
        <p class="tag-source">
            <a href="node_modules_chai_lib_chai_core_assertions.js.html" class="button">View Source</a>
            <span>
                <a href="node_modules_chai_lib_chai_core_assertions.js.html">node_modules/chai/lib/chai/core/assertions.js</a>, <a href="node_modules_chai_lib_chai_core_assertions.js.html#line2924">line 2924</a>
            </span>
        </p>
    
</dl>


        
    
    </div>
    
    

    

    

    

    

    

    

    

    

    
</article>

</section>







<section>

<header>
    
        <h2>BDD</h2>
        
    
</header>

<article>
    <div class="container-overview">
    
        
            <div class="description"><h3>.members(set[, msg])</h3>
<p>Asserts that the target array has the same members as the given array
<code>set</code>.</p>
<pre><code>expect([1, 2, 3]).to.have.members([2, 1, 3]);
expect([1, 2, 2]).to.have.members([2, 1, 2]);
</code></pre>
<p>By default, members are compared using strict (<code>===</code>) equality. Add <code>.deep</code>
earlier in the chain to use deep equality instead. See the <code>deep-eql</code>
project page for info on the deep equality algorithm:
https://github.com/chaijs/deep-eql.</p>
<pre><code>// Target array deeply (but not strictly) has member `{a: 1}`
expect([{a: 1}]).to.have.deep.members([{a: 1}]);
expect([{a: 1}]).to.not.have.members([{a: 1}]);
</code></pre>
<p>By default, order doesn't matter. Add <code>.ordered</code> earlier in the chain to
require that members appear in the same order.</p>
<pre><code>expect([1, 2, 3]).to.have.ordered.members([1, 2, 3]);
expect([1, 2, 3]).to.have.members([2, 1, 3])
  .but.not.ordered.members([2, 1, 3]);
</code></pre>
<p>By default, both arrays must be the same size. Add <code>.include</code> earlier in
the chain to require that the target's members be a superset of the
expected members. Note that duplicates are ignored in the subset when
<code>.include</code> is added.</p>
<pre><code>// Target array is a superset of [1, 2] but not identical
expect([1, 2, 3]).to.include.members([1, 2]);
expect([1, 2, 3]).to.not.have.members([1, 2]);

// Duplicates in the subset are ignored
expect([1, 2, 3]).to.include.members([1, 2, 2, 2]);
</code></pre>
<p><code>.deep</code>, <code>.ordered</code>, and <code>.include</code> can all be combined. However, if
<code>.include</code> and <code>.ordered</code> are combined, the ordering begins at the start of
both arrays.</p>
<pre><code>expect([{a: 1}, {b: 2}, {c: 3}])
  .to.include.deep.ordered.members([{a: 1}, {b: 2}])
  .but.not.include.deep.ordered.members([{b: 2}, {c: 3}]);
</code></pre>
<p>Add <code>.not</code> earlier in the chain to negate <code>.members</code>. However, it's
dangerous to do so. The problem is that it creates uncertain expectations
by asserting that the target array doesn't have all of the same members as
the given array <code>set</code> but may or may not have some of them. It's often best
to identify the exact output that's expected, and then write an assertion
that only accepts that exact output.</p>
<pre><code>expect([1, 2]).to.not.include(3).and.not.include(4); // Recommended
expect([1, 2]).to.not.have.members([3, 4]); // Not recommended
</code></pre>
<p><code>.members</code> accepts an optional <code>msg</code> argument which is a custom error
message to show when the assertion fails. The message can also be given as
the second argument to <code>expect</code>.</p>
<pre><code>expect([1, 2]).to.have.members([1, 2, 3], 'nooo why fail??');
expect([1, 2], 'nooo why fail??').to.have.members([1, 2, 3]);</code></pre></div>
        

        


<dl class="details">

    

    

    

    

    

    

    

    

    

    

    

    
    

    

    

    
        <p class="tag-source">
            <a href="node_modules_chai_lib_chai_core_assertions.js.html" class="button">View Source</a>
            <span>
                <a href="node_modules_chai_lib_chai_core_assertions.js.html">node_modules/chai/lib/chai/core/assertions.js</a>, <a href="node_modules_chai_lib_chai_core_assertions.js.html#line3018">line 3018</a>
            </span>
        </p>
    
</dl>


        
    
    </div>
    
    

    

    

    

    

    

    

    

    

    
</article>

</section>







<section>

<header>
    
        <h2>BDD</h2>
        
    
</header>

<article>
    <div class="container-overview">
    
        
            <div class="description"><h3>.oneOf(list[, msg])</h3>
<p>Asserts that the target is a member of the given array <code>list</code>. However,
it's often best to assert that the target is equal to its expected value.</p>
<pre><code>expect(1).to.equal(1); // Recommended
expect(1).to.be.oneOf([1, 2, 3]); // Not recommended
</code></pre>
<p>Comparisons are performed using strict (<code>===</code>) equality.</p>
<p>Add <code>.not</code> earlier in the chain to negate <code>.oneOf</code>.</p>
<pre><code>expect(1).to.equal(1); // Recommended
expect(1).to.not.be.oneOf([2, 3, 4]); // Not recommended
</code></pre>
<p>It can also be chained with <code>.contain</code> or <code>.include</code>, which will work with
both arrays and strings:</p>
<pre><code>expect('Today is sunny').to.contain.oneOf(['sunny', 'cloudy'])
expect('Today is rainy').to.not.contain.oneOf(['sunny', 'cloudy'])
expect([1,2,3]).to.contain.oneOf([3,4,5])
expect([1,2,3]).to.not.contain.oneOf([4,5,6])
</code></pre>
<p><code>.oneOf</code> accepts an optional <code>msg</code> argument which is a custom error message
to show when the assertion fails. The message can also be given as the
second argument to <code>expect</code>.</p>
<pre><code>expect(1).to.be.oneOf([2, 3, 4], 'nooo why fail??');
expect(1, 'nooo why fail??').to.be.oneOf([2, 3, 4]);</code></pre></div>
        

        


<dl class="details">

    

    

    

    

    

    

    

    

    

    

    

    
    

    

    

    
        <p class="tag-source">
            <a href="node_modules_chai_lib_chai_core_assertions.js.html" class="button">View Source</a>
            <span>
                <a href="node_modules_chai_lib_chai_core_assertions.js.html">node_modules/chai/lib/chai/core/assertions.js</a>, <a href="node_modules_chai_lib_chai_core_assertions.js.html#line3123">line 3123</a>
            </span>
        </p>
    
</dl>


        
    
    </div>
    
    

    

    

    

    

    

    

    

    

    
</article>

</section>







<section>

<header>
    
        <h2>BDD</h2>
        
    
</header>

<article>
    <div class="container-overview">
    
        
            <div class="description"><h3>.change(subject[, prop[, msg]])</h3>
<p>When one argument is provided, <code>.change</code> asserts that the given function
<code>subject</code> returns a different value when it's invoked before the target
function compared to when it's invoked afterward. However, it's often best
to assert that <code>subject</code> is equal to its expected value.</p>
<pre><code>var dots = ''
  , addDot = function () { dots += '.'; }
  , getDots = function () { return dots; };

// Recommended
expect(getDots()).to.equal('');
addDot();
expect(getDots()).to.equal('.');

// Not recommended
expect(addDot).to.change(getDots);
</code></pre>
<p>When two arguments are provided, <code>.change</code> asserts that the value of the
given object <code>subject</code>'s <code>prop</code> property is different before invoking the
target function compared to afterward.</p>
<pre><code>var myObj = {dots: ''}
  , addDot = function () { myObj.dots += '.'; };

// Recommended
expect(myObj).to.have.property('dots', '');
addDot();
expect(myObj).to.have.property('dots', '.');

// Not recommended
expect(addDot).to.change(myObj, 'dots');
</code></pre>
<p>Strict (<code>===</code>) equality is used to compare before and after values.</p>
<p>Add <code>.not</code> earlier in the chain to negate <code>.change</code>.</p>
<pre><code>var dots = ''
  , noop = function () {}
  , getDots = function () { return dots; };

expect(noop).to.not.change(getDots);

var myObj = {dots: ''}
  , noop = function () {};

expect(noop).to.not.change(myObj, 'dots');
</code></pre>
<p><code>.change</code> accepts an optional <code>msg</code> argument which is a custom error
message to show when the assertion fails. The message can also be given as
the second argument to <code>expect</code>. When not providing two arguments, always
use the second form.</p>
<pre><code>var myObj = {dots: ''}
  , addDot = function () { myObj.dots += '.'; };

expect(addDot).to.not.change(myObj, 'dots', 'nooo why fail??');

var dots = ''
  , addDot = function () { dots += '.'; }
  , getDots = function () { return dots; };

expect(addDot, 'nooo why fail??').to.not.change(getDots);
</code></pre>
<p><code>.change</code> also causes all <code>.by</code> assertions that follow in the chain to
assert how much a numeric subject was increased or decreased by. However,
it's dangerous to use <code>.change.by</code>. The problem is that it creates
uncertain expectations by asserting that the subject either increases by
the given delta, or that it decreases by the given delta. It's often best
to identify the exact output that's expected, and then write an assertion
that only accepts that exact output.</p>
<pre><code>var myObj = {val: 1}
  , addTwo = function () { myObj.val += 2; }
  , subtractTwo = function () { myObj.val -= 2; };

expect(addTwo).to.increase(myObj, 'val').by(2); // Recommended
expect(addTwo).to.change(myObj, 'val').by(2); // Not recommended

expect(subtractTwo).to.decrease(myObj, 'val').by(2); // Recommended
expect(subtractTwo).to.change(myObj, 'val').by(2); // Not recommended
</code></pre>
<p>The alias <code>.changes</code> can be used interchangeably with <code>.change</code>.</p></div>
        

        


<dl class="details">

    

    

    

    

    

    

    

    

    

    

    

    
    

    

    

    
        <p class="tag-source">
            <a href="node_modules_chai_lib_chai_core_assertions.js.html" class="button">View Source</a>
            <span>
                <a href="node_modules_chai_lib_chai_core_assertions.js.html">node_modules/chai/lib/chai/core/assertions.js</a>, <a href="node_modules_chai_lib_chai_core_assertions.js.html#line3201">line 3201</a>
            </span>
        </p>
    
</dl>


        
    
    </div>
    
    

    

    

    

    

    

    

    

    

    
</article>

</section>







<section>

<header>
    
        <h2>BDD</h2>
        
    
</header>

<article>
    <div class="container-overview">
    
        
            <div class="description"><h3>.increase(subject[, prop[, msg]])</h3>
<p>When one argument is provided, <code>.increase</code> asserts that the given function
<code>subject</code> returns a greater number when it's invoked after invoking the
target function compared to when it's invoked beforehand. <code>.increase</code> also
causes all <code>.by</code> assertions that follow in the chain to assert how much
greater of a number is returned. It's often best to assert that the return
value increased by the expected amount, rather than asserting it increased
by any amount.</p>
<pre><code>var val = 1
  , addTwo = function () { val += 2; }
  , getVal = function () { return val; };

expect(addTwo).to.increase(getVal).by(2); // Recommended
expect(addTwo).to.increase(getVal); // Not recommended
</code></pre>
<p>When two arguments are provided, <code>.increase</code> asserts that the value of the
given object <code>subject</code>'s <code>prop</code> property is greater after invoking the
target function compared to beforehand.</p>
<pre><code>var myObj = {val: 1}
  , addTwo = function () { myObj.val += 2; };

expect(addTwo).to.increase(myObj, 'val').by(2); // Recommended
expect(addTwo).to.increase(myObj, 'val'); // Not recommended
</code></pre>
<p>Add <code>.not</code> earlier in the chain to negate <code>.increase</code>. However, it's
dangerous to do so. The problem is that it creates uncertain expectations
by asserting that the subject either decreases, or that it stays the same.
It's often best to identify the exact output that's expected, and then
write an assertion that only accepts that exact output.</p>
<p>When the subject is expected to decrease, it's often best to assert that it
decreased by the expected amount.</p>
<pre><code>var myObj = {val: 1}
  , subtractTwo = function () { myObj.val -= 2; };

expect(subtractTwo).to.decrease(myObj, 'val').by(2); // Recommended
expect(subtractTwo).to.not.increase(myObj, 'val'); // Not recommended
</code></pre>
<p>When the subject is expected to stay the same, it's often best to assert
exactly that.</p>
<pre><code>var myObj = {val: 1}
  , noop = function () {};

expect(noop).to.not.change(myObj, 'val'); // Recommended
expect(noop).to.not.increase(myObj, 'val'); // Not recommended
</code></pre>
<p><code>.increase</code> accepts an optional <code>msg</code> argument which is a custom error
message to show when the assertion fails. The message can also be given as
the second argument to <code>expect</code>. When not providing two arguments, always
use the second form.</p>
<pre><code>var myObj = {val: 1}
  , noop = function () {};

expect(noop).to.increase(myObj, 'val', 'nooo why fail??');

var val = 1
  , noop = function () {}
  , getVal = function () { return val; };

expect(noop, 'nooo why fail??').to.increase(getVal);
</code></pre>
<p>The alias <code>.increases</code> can be used interchangeably with <code>.increase</code>.</p></div>
        

        


<dl class="details">

    

    

    

    

    

    

    

    

    

    

    

    
    

    

    

    
        <p class="tag-source">
            <a href="node_modules_chai_lib_chai_core_assertions.js.html" class="button">View Source</a>
            <span>
                <a href="node_modules_chai_lib_chai_core_assertions.js.html">node_modules/chai/lib/chai/core/assertions.js</a>, <a href="node_modules_chai_lib_chai_core_assertions.js.html#line3334">line 3334</a>
            </span>
        </p>
    
</dl>


        
    
    </div>
    
    

    

    

    

    

    

    

    

    

    
</article>

</section>







<section>

<header>
    
        <h2>BDD</h2>
        
    
</header>

<article>
    <div class="container-overview">
    
        
            <div class="description"><h3>.decrease(subject[, prop[, msg]])</h3>
<p>When one argument is provided, <code>.decrease</code> asserts that the given function
<code>subject</code> returns a lesser number when it's invoked after invoking the
target function compared to when it's invoked beforehand. <code>.decrease</code> also
causes all <code>.by</code> assertions that follow in the chain to assert how much
lesser of a number is returned. It's often best to assert that the return
value decreased by the expected amount, rather than asserting it decreased
by any amount.</p>
<pre><code>var val = 1
  , subtractTwo = function () { val -= 2; }
  , getVal = function () { return val; };

expect(subtractTwo).to.decrease(getVal).by(2); // Recommended
expect(subtractTwo).to.decrease(getVal); // Not recommended
</code></pre>
<p>When two arguments are provided, <code>.decrease</code> asserts that the value of the
given object <code>subject</code>'s <code>prop</code> property is lesser after invoking the
target function compared to beforehand.</p>
<pre><code>var myObj = {val: 1}
  , subtractTwo = function () { myObj.val -= 2; };

expect(subtractTwo).to.decrease(myObj, 'val').by(2); // Recommended
expect(subtractTwo).to.decrease(myObj, 'val'); // Not recommended
</code></pre>
<p>Add <code>.not</code> earlier in the chain to negate <code>.decrease</code>. However, it's
dangerous to do so. The problem is that it creates uncertain expectations
by asserting that the subject either increases, or that it stays the same.
It's often best to identify the exact output that's expected, and then
write an assertion that only accepts that exact output.</p>
<p>When the subject is expected to increase, it's often best to assert that it
increased by the expected amount.</p>
<pre><code>var myObj = {val: 1}
  , addTwo = function () { myObj.val += 2; };

expect(addTwo).to.increase(myObj, 'val').by(2); // Recommended
expect(addTwo).to.not.decrease(myObj, 'val'); // Not recommended
</code></pre>
<p>When the subject is expected to stay the same, it's often best to assert
exactly that.</p>
<pre><code>var myObj = {val: 1}
  , noop = function () {};

expect(noop).to.not.change(myObj, 'val'); // Recommended
expect(noop).to.not.decrease(myObj, 'val'); // Not recommended
</code></pre>
<p><code>.decrease</code> accepts an optional <code>msg</code> argument which is a custom error
message to show when the assertion fails. The message can also be given as
the second argument to <code>expect</code>. When not providing two arguments, always
use the second form.</p>
<pre><code>var myObj = {val: 1}
  , noop = function () {};

expect(noop).to.decrease(myObj, 'val', 'nooo why fail??');

var val = 1
  , noop = function () {}
  , getVal = function () { return val; };

expect(noop, 'nooo why fail??').to.decrease(getVal);
</code></pre>
<p>The alias <code>.decreases</code> can be used interchangeably with <code>.decrease</code>.</p></div>
        

        


<dl class="details">

    

    

    

    

    

    

    

    

    

    

    

    
    

    

    

    
        <p class="tag-source">
            <a href="node_modules_chai_lib_chai_core_assertions.js.html" class="button">View Source</a>
            <span>
                <a href="node_modules_chai_lib_chai_core_assertions.js.html">node_modules/chai/lib/chai/core/assertions.js</a>, <a href="node_modules_chai_lib_chai_core_assertions.js.html#line3453">line 3453</a>
            </span>
        </p>
    
</dl>


        
    
    </div>
    
    

    

    

    

    

    

    

    

    

    
</article>

</section>







<section>

<header>
    
        <h2>BDD</h2>
        
    
</header>

<article>
    <div class="container-overview">
    
        
            <div class="description"><h3>.by(delta[, msg])</h3>
<p>When following an <code>.increase</code> assertion in the chain, <code>.by</code> asserts that
the subject of the <code>.increase</code> assertion increased by the given <code>delta</code>.</p>
<pre><code>var myObj = {val: 1}
  , addTwo = function () { myObj.val += 2; };

expect(addTwo).to.increase(myObj, 'val').by(2);
</code></pre>
<p>When following a <code>.decrease</code> assertion in the chain, <code>.by</code> asserts that the
subject of the <code>.decrease</code> assertion decreased by the given <code>delta</code>.</p>
<pre><code>var myObj = {val: 1}
  , subtractTwo = function () { myObj.val -= 2; };

expect(subtractTwo).to.decrease(myObj, 'val').by(2);
</code></pre>
<p>When following a <code>.change</code> assertion in the chain, <code>.by</code> asserts that the
subject of the <code>.change</code> assertion either increased or decreased by the
given <code>delta</code>. However, it's dangerous to use <code>.change.by</code>. The problem is
that it creates uncertain expectations. It's often best to identify the
exact output that's expected, and then write an assertion that only accepts
that exact output.</p>
<pre><code>var myObj = {val: 1}
  , addTwo = function () { myObj.val += 2; }
  , subtractTwo = function () { myObj.val -= 2; };

expect(addTwo).to.increase(myObj, 'val').by(2); // Recommended
expect(addTwo).to.change(myObj, 'val').by(2); // Not recommended

expect(subtractTwo).to.decrease(myObj, 'val').by(2); // Recommended
expect(subtractTwo).to.change(myObj, 'val').by(2); // Not recommended
</code></pre>
<p>Add <code>.not</code> earlier in the chain to negate <code>.by</code>. However, it's often best
to assert that the subject changed by its expected delta, rather than
asserting that it didn't change by one of countless unexpected deltas.</p>
<pre><code>var myObj = {val: 1}
  , addTwo = function () { myObj.val += 2; };

// Recommended
expect(addTwo).to.increase(myObj, 'val').by(2);

// Not recommended
expect(addTwo).to.increase(myObj, 'val').but.not.by(3);
</code></pre>
<p><code>.by</code> accepts an optional <code>msg</code> argument which is a custom error message to
show when the assertion fails. The message can also be given as the second
argument to <code>expect</code>.</p>
<pre><code>var myObj = {val: 1}
  , addTwo = function () { myObj.val += 2; };

expect(addTwo).to.increase(myObj, 'val').by(3, 'nooo why fail??');
expect(addTwo, 'nooo why fail??').to.increase(myObj, 'val').by(3);</code></pre></div>
        

        


<dl class="details">

    

    

    

    

    

    

    

    

    

    

    

    
    

    

    

    
        <p class="tag-source">
            <a href="node_modules_chai_lib_chai_core_assertions.js.html" class="button">View Source</a>
            <span>
                <a href="node_modules_chai_lib_chai_core_assertions.js.html">node_modules/chai/lib/chai/core/assertions.js</a>, <a href="node_modules_chai_lib_chai_core_assertions.js.html#line3572">line 3572</a>
            </span>
        </p>
    
</dl>


        
    
    </div>
    
    

    

    

    

    

    

    

    

    

    
</article>

</section>







<section>

<header>
    
        <h2>BDD</h2>
        
    
</header>

<article>
    <div class="container-overview">
    
        
            <div class="description"><h3>.extensible</h3>
<p>Asserts that the target is extensible, which means that new properties can
be added to it. Primitives are never extensible.</p>
<pre><code>expect({a: 1}).to.be.extensible;
</code></pre>
<p>Add <code>.not</code> earlier in the chain to negate <code>.extensible</code>.</p>
<pre><code>var nonExtensibleObject = Object.preventExtensions({})
  , sealedObject = Object.seal({})
  , frozenObject = Object.freeze({});

expect(nonExtensibleObject).to.not.be.extensible;
expect(sealedObject).to.not.be.extensible;
expect(frozenObject).to.not.be.extensible;
expect(1).to.not.be.extensible;
</code></pre>
<p>A custom error message can be given as the second argument to <code>expect</code>.</p>
<pre><code>expect(1, 'nooo why fail??').to.be.extensible;</code></pre></div>
        

        


<dl class="details">

    

    

    

    

    

    

    

    

    

    

    

    
    

    

    

    
        <p class="tag-source">
            <a href="node_modules_chai_lib_chai_core_assertions.js.html" class="button">View Source</a>
            <span>
                <a href="node_modules_chai_lib_chai_core_assertions.js.html">node_modules/chai/lib/chai/core/assertions.js</a>, <a href="node_modules_chai_lib_chai_core_assertions.js.html#line3663">line 3663</a>
            </span>
        </p>
    
</dl>


        
    
    </div>
    
    

    

    

    

    

    

    

    

    

    
</article>

</section>







<section>

<header>
    
        <h2>BDD</h2>
        
    
</header>

<article>
    <div class="container-overview">
    
        
            <div class="description"><h3>.sealed</h3>
<p>Asserts that the target is sealed, which means that new properties can't be
added to it, and its existing properties can't be reconfigured or deleted.
However, it's possible that its existing properties can still be reassigned
to different values. Primitives are always sealed.</p>
<pre><code>var sealedObject = Object.seal({});
var frozenObject = Object.freeze({});

expect(sealedObject).to.be.sealed;
expect(frozenObject).to.be.sealed;
expect(1).to.be.sealed;
</code></pre>
<p>Add <code>.not</code> earlier in the chain to negate <code>.sealed</code>.</p>
<pre><code>expect({a: 1}).to.not.be.sealed;
</code></pre>
<p>A custom error message can be given as the second argument to <code>expect</code>.</p>
<pre><code>expect({a: 1}, 'nooo why fail??').to.be.sealed;</code></pre></div>
        

        


<dl class="details">

    

    

    

    

    

    

    

    

    

    

    

    
    

    

    

    
        <p class="tag-source">
            <a href="node_modules_chai_lib_chai_core_assertions.js.html" class="button">View Source</a>
            <span>
                <a href="node_modules_chai_lib_chai_core_assertions.js.html">node_modules/chai/lib/chai/core/assertions.js</a>, <a href="node_modules_chai_lib_chai_core_assertions.js.html#line3708">line 3708</a>
            </span>
        </p>
    
</dl>


        
    
    </div>
    
    

    

    

    

    

    

    

    

    

    
</article>

</section>







<section>

<header>
    
        <h2>BDD</h2>
        
    
</header>

<article>
    <div class="container-overview">
    
        
            <div class="description"><h3>.frozen</h3>
<p>Asserts that the target is frozen, which means that new properties can't be
added to it, and its existing properties can't be reassigned to different
values, reconfigured, or deleted. Primitives are always frozen.</p>
<pre><code>var frozenObject = Object.freeze({});

expect(frozenObject).to.be.frozen;
expect(1).to.be.frozen;
</code></pre>
<p>Add <code>.not</code> earlier in the chain to negate <code>.frozen</code>.</p>
<pre><code>expect({a: 1}).to.not.be.frozen;
</code></pre>
<p>A custom error message can be given as the second argument to <code>expect</code>.</p>
<pre><code>expect({a: 1}, 'nooo why fail??').to.be.frozen;</code></pre></div>
        

        


<dl class="details">

    

    

    

    

    

    

    

    

    

    

    

    
    

    

    

    
        <p class="tag-source">
            <a href="node_modules_chai_lib_chai_core_assertions.js.html" class="button">View Source</a>
            <span>
                <a href="node_modules_chai_lib_chai_core_assertions.js.html">node_modules/chai/lib/chai/core/assertions.js</a>, <a href="node_modules_chai_lib_chai_core_assertions.js.html#line3753">line 3753</a>
            </span>
        </p>
    
</dl>


        
    
    </div>
    
    

    

    

    

    

    

    

    

    

    
</article>

</section>







<section>

<header>
    
        <h2>BDD</h2>
        
    
</header>

<article>
    <div class="container-overview">
    
        
            <div class="description"><h3>.finite</h3>
<p>Asserts that the target is a number, and isn't <code>NaN</code> or positive/negative
<code>Infinity</code>.</p>
<pre><code>expect(1).to.be.finite;
</code></pre>
<p>Add <code>.not</code> earlier in the chain to negate <code>.finite</code>. However, it's
dangerous to do so. The problem is that it creates uncertain expectations
by asserting that the subject either isn't a number, or that it's <code>NaN</code>, or
that it's positive <code>Infinity</code>, or that it's negative <code>Infinity</code>. It's often
best to identify the exact output that's expected, and then write an
assertion that only accepts that exact output.</p>
<p>When the target isn't expected to be a number, it's often best to assert
that it's the expected type, rather than asserting that it isn't one of
many unexpected types.</p>
<pre><code>expect('foo').to.be.a('string'); // Recommended
expect('foo').to.not.be.finite; // Not recommended
</code></pre>
<p>When the target is expected to be <code>NaN</code>, it's often best to assert exactly
that.</p>
<pre><code>expect(NaN).to.be.NaN; // Recommended
expect(NaN).to.not.be.finite; // Not recommended
</code></pre>
<p>When the target is expected to be positive infinity, it's often best to
assert exactly that.</p>
<pre><code>expect(Infinity).to.equal(Infinity); // Recommended
expect(Infinity).to.not.be.finite; // Not recommended
</code></pre>
<p>When the target is expected to be negative infinity, it's often best to
assert exactly that.</p>
<pre><code>expect(-Infinity).to.equal(-Infinity); // Recommended
expect(-Infinity).to.not.be.finite; // Not recommended
</code></pre>
<p>A custom error message can be given as the second argument to <code>expect</code>.</p>
<pre><code>expect('foo', 'nooo why fail??').to.be.finite;</code></pre></div>
        

        


<dl class="details">

    

    

    

    

    

    

    

    

    

    

    

    
    

    

    

    
        <p class="tag-source">
            <a href="node_modules_chai_lib_chai_core_assertions.js.html" class="button">View Source</a>
            <span>
                <a href="node_modules_chai_lib_chai_core_assertions.js.html">node_modules/chai/lib/chai/core/assertions.js</a>, <a href="node_modules_chai_lib_chai_core_assertions.js.html#line3795">line 3795</a>
            </span>
        </p>
    
</dl>


        
    
    </div>
    
    

    

    

    

    

    

    

    

    

    
</article>

</section>







<section>

<header>
    
        <h2>BDD</h2>
        
    
</header>

<article>
    <div class="container-overview">
    
        
            <div class="description"><h3>.fail([message])</h3>
<h3>.fail(actual, expected, [message], [operator])</h3>
<p>Throw a failure.</p>
<pre><code>expect.fail();
expect.fail(&quot;custom error message&quot;);
expect.fail(1, 2);
expect.fail(1, 2, &quot;custom error message&quot;);
expect.fail(1, 2, &quot;custom error message&quot;, &quot;&gt;&quot;);
expect.fail(1, 2, undefined, &quot;&gt;&quot;);</code></pre></div>
        

        


<dl class="details">

    

    

    

    

    

    

    

    

    

    

    

    
    

    

    

    
        <p class="tag-source">
            <a href="node_modules_chai_lib_chai_interface_expect.js.html" class="button">View Source</a>
            <span>
                <a href="node_modules_chai_lib_chai_interface_expect.js.html">node_modules/chai/lib/chai/interface/expect.js</a>, <a href="node_modules_chai_lib_chai_interface_expect.js.html#line12">line 12</a>
            </span>
        </p>
    
</dl>


        
    
    </div>
    
    

    

    

    

    

    

    

    

    

    
</article>

</section>







<section>

<header>
    
        <h2>BDD</h2>
        
    
</header>

<article>
    <div class="container-overview">
    
        
            <div class="description"><h3>.fail([message])</h3>
<h3>.fail(actual, expected, [message], [operator])</h3>
<p>Throw a failure.</p>
<pre><code>should.fail();
should.fail(&quot;custom error message&quot;);
should.fail(1, 2);
should.fail(1, 2, &quot;custom error message&quot;);
should.fail(1, 2, &quot;custom error message&quot;, &quot;&gt;&quot;);
should.fail(1, 2, undefined, &quot;&gt;&quot;);</code></pre></div>
        

        


<dl class="details">

    

    

    

    

    

    

    

    

    

    

    

    
    

    

    

    
        <p class="tag-source">
            <a href="node_modules_chai_lib_chai_interface_should.js.html" class="button">View Source</a>
            <span>
                <a href="node_modules_chai_lib_chai_interface_should.js.html">node_modules/chai/lib/chai/interface/should.js</a>, <a href="node_modules_chai_lib_chai_interface_should.js.html#line45">line 45</a>
            </span>
        </p>
    
</dl>


        
    
    </div>
    
    

    

    

    

    

    

    

    

    

    
</article>

</section>




            </div>
            
            <footer class="footer">
                <div class="content has-text-centered">
                    <p>Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.6.7</a></p>
                    <p class="sidebar-created-by">
                        <a href="https://github.com/SoftwareBrothers/better-docs" target="_blank">BetterDocs theme</a> provided with <i class="fas fa-heart"></i> by 
                        <a href="http://softwarebrothers.co" target="_blank">SoftwareBrothers - JavaScript Development Agency</a>
                    </p>
                </div>
            </footer>
            
        </div>
        <div id="side-nav" class="side-nav">
        </div>
    </div>
<script src="scripts/app.min.js"></script>
<script>PR.prettyPrint();</script>
<script src="scripts/linenumber.js"> </script>

<script src="scripts/search.js"> </script>

</body>
</html>